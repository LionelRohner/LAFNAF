# make loop even easier
for (col in currentCol:nc){
# skip if col is zero
if (all(A[-c(1:currentRow),col] == 0)){
next
}
# go one row down to follow the diagonal if the column is not full of zeros
currentRow = currentRow + 1
# create new pivot
A[currentRow,] = (1/A[currentRow,col]) * A[currentRow,]
# add pivot index
idxPivots = rbind(idxPivots,c(currentRow, col))
# 3.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = col)){
# find nonzero elements in col. vector
idxNonzero = which(A[-c(1:currentRow),col]!=0) + col
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,col)
}
}
# 4.) Now remove all free variable above a pivot
# create matrix containing only the pivots
pivotsVec <- A[idxPivots$i,]
#
nr = nrow(pivotsVec)
# this loop starts with the "lowest" pivot vector (piv) (the one with rightmost pivot)
# and subtracts itself from the next pivot (revPiv) vector such that the free variable
# above the current pivot vector (piv).
for (piv in nr:1){
for (revPiv in piv:1){
if(piv == revPiv){
next
}
A[revPiv,] = A[revPiv,]-A[piv,]*A[revPiv,piv]
}
}
# 5.) set small values to zero
ifelse(abs(A) <= 1e-10, 0, A)
return(A)
}
# clear rref!!
pracma::rref(A)
rref(A)
rref <- function(A){
# Corner Case 1: all zero matrix
if (max(abs(A)) == 0){
return(A)
}
# 1.) Setup variables
nc = ncol(A)
nr = nrow(A)
# first pivot must be on first column
currentCol = 1
idxPivots = data.frame(i = 1, j = 1)
# 1.1.) remove parallel vectors
rmIdx = unique(linDep_Cautchy_Schwartz_Matrix(A)$j)
# 1.2.) set small values to zero
ifelse(abs(A) <= 1e-10, 0, A)
# put zero-vector and parallel vectors at the bottom
if (!is.null(rmIdx)){
A[rmIdx,] <- rep(0,nc)
A <- add_To_Bottom(A,rmIdx)
}
# 2.) find first pivot (if exists, else normalize first row to first element)
firstPivotIdx = which(A[,1]==1)[1]
# check if a pivot exists?
if (!is.na(firstPivotIdx)){
A <- swap(A,firstPivotIdx,1)
} else {
# Create a pivot (normalize first row)
A[1,] = (1/A[1,1]) * A[1,]
}
# 2.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = currentCol)){
# find nonzero elements in col. vector
idxNonzero = which(A[-1,currentCol]!=0) + currentCol
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,currentCol)
}
# 2.2.) Reorganize matrix such that zero vectors are at the bottom, rm parallel vectors
A = swap_Zero_Vectors(A)
A = remove_Parallel_Vectors(A)
# 3.) find potential next pivots and swap rows if exist
currentCol = 2
currentRow = 1
# make loop even easier
for (col in currentCol:nc){
# skip if col is zero
if (all(A[-c(1:currentRow),col] == 0)){
next
}
# go one row down to follow the diagonal if the column is not full of zeros
currentRow = currentRow + 1
# create new pivot
A[currentRow,] = (1/A[currentRow,col]) * A[currentRow,]
# add pivot index
idxPivots = rbind(idxPivots,c(currentRow, col))
# 3.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = col)){
# find nonzero elements in col. vector
idxNonzero = which(A[-c(1:currentRow),col]!=0) + col
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,col)
}
}
# 4.) Now remove all free variable above a pivot
# create matrix containing only the pivots
pivotsVec <- A[idxPivots$i,]
#
nr = nrow(pivotsVec)
# this loop starts with the "lowest" pivot vector (piv) (the one with rightmost pivot)
# and subtracts itself from the next pivot (revPiv) vector such that the free variable
# above the current pivot vector (piv).
for (piv in nr:1){
for (revPiv in piv:1){
if(piv == revPiv){
next
}
A[revPiv,] = A[revPiv,]-A[piv,]*A[revPiv,piv]
}
}
# 5.) set small values to zero
ifelse(abs(A) <= 1e-10, 0, A)
return(A)
}
# clear rref!!
pracma::rref(A)
rref(A)
A2 <- rref(A)
ifelse(abs(A2) <= 1e-10, 0, A2)
A2
rref <- function(A){
# Corner Case 1: all zero matrix
if (max(abs(A)) == 0){
return(A)
}
# 1.) Setup variables
nc = ncol(A)
nr = nrow(A)
# first pivot must be on first column
currentCol = 1
idxPivots = data.frame(i = 1, j = 1)
# 1.1.) remove parallel vectors
rmIdx = unique(linDep_Cautchy_Schwartz_Matrix(A)$j)
# # 1.2.) set small values to zero
# ifelse(abs(A) <= 1e-10, 0, A)
# put zero-vector and parallel vectors at the bottom
if (!is.null(rmIdx)){
A[rmIdx,] <- rep(0,nc)
A <- add_To_Bottom(A,rmIdx)
}
# 2.) find first pivot (if exists, else normalize first row to first element)
firstPivotIdx = which(A[,1]==1)[1]
# check if a pivot exists?
if (!is.na(firstPivotIdx)){
A <- swap(A,firstPivotIdx,1)
} else {
# Create a pivot (normalize first row)
A[1,] = (1/A[1,1]) * A[1,]
}
# 2.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = currentCol)){
# find nonzero elements in col. vector
idxNonzero = which(A[-1,currentCol]!=0) + currentCol
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,currentCol)
}
# 2.2.) Reorganize matrix such that zero vectors are at the bottom, rm parallel vectors
A = swap_Zero_Vectors(A)
A = remove_Parallel_Vectors(A)
# 3.) find potential next pivots and swap rows if exist
currentCol = 2
currentRow = 1
# make loop even easier
for (col in currentCol:nc){
# skip if col is zero
if (all(A[-c(1:currentRow),col] == 0)){
next
}
# go one row down to follow the diagonal if the column is not full of zeros
currentRow = currentRow + 1
# create new pivot
A[currentRow,] = (1/A[currentRow,col]) * A[currentRow,]
# add pivot index
idxPivots = rbind(idxPivots,c(currentRow, col))
# 3.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = col)){
# find nonzero elements in col. vector
idxNonzero = which(A[-c(1:currentRow),col]!=0) + col
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,col)
}
}
# 4.) Now remove all free variable above a pivot
# create matrix containing only the pivots
pivotsVec <- A[idxPivots$i,]
#
nr = nrow(pivotsVec)
# this loop starts with the "lowest" pivot vector (piv) (the one with rightmost pivot)
# and subtracts itself from the next pivot (revPiv) vector such that the free variable
# above the current pivot vector (piv).
for (piv in nr:1){
for (revPiv in piv:1){
if(piv == revPiv){
next
}
A[revPiv,] = A[revPiv,]-A[piv,]*A[revPiv,piv]
}
}
# 5.) set small values to zero
A = ifelse(abs(A) <= 1e-10, 0, A)
return(A)
}
# clear rref!!
pracma::rref(A)
A2 <- rref(A)
rref(A)
# lin dep
A <- t(matrix(c(1,2,3,4,
1,2,3,4,
1,2,3,4,
1,2,3,4),nrow = 4))
# clear rref!!
pracma::rref(A)
rref(A)
# lin dep (row space)
A <- t(matrix(c(1,-3,5,
0,1,7,
2,-4,28,
3,-13,0,
4,-14,-3,
5,-9,30,
6,2,173), nrow = 3))
# clear rref!!
pracma::rref(A)
rref(A)
# full rank 3x3
A <- t(matrix(c(1,2,3,
-1,0,1,
7,1,-2), nrow = 3))
# clear rref!!
pracma::rref(A)
rref(A)
# full rank 3x3
A <- t(matrix(c(1,2,3,
-1,0,1,
7,1,-2), nrow = 3))
# clear rref!!
pracma::rref(A)
rref(A)
# from p.126 (matrix book) --> works for UDU-1
A <- t(matrix(c(-1,-2,-2,
1,2,1,
-1,-1,-1), nrow = 3))
# clear rref!!
pracma::rref(A)
rref(A)
rref <- function(A){
# Corner Case 1: all zero matrix
if (max(abs(A)) == 0){
return(A)
}
# 1.) Setup variables
nc = ncol(A)
nr = nrow(A)
# first pivot must be on first column
currentCol = 1
idxPivots = data.frame(i = 1, j = 1)
# 1.1.) remove parallel vectors
rmIdx = unique(linDep_Cautchy_Schwartz_Matrix(A)$j)
# # 1.2.) set small values to zero
# ifelse(abs(A) <= 1e-10, 0, A)
# put zero-vector and parallel vectors at the bottom
if (!is.null(rmIdx)){
A[rmIdx,] <- rep(0,nc)
A <- add_To_Bottom(A,rmIdx)
}
# 2.) find first pivot (if exists, else normalize first row to first element)
firstPivotIdx = which(A[,1]==1)[1]
# check if a pivot exists?
if (!is.na(firstPivotIdx)){
A <- swap(A,firstPivotIdx,1)
} else {
# Create a pivot (normalize first row)
A[1,] = (1/A[1,1]) * A[1,]
}
# 2.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = currentCol)){
# find nonzero elements in col. vector
idxNonzero = which(A[-1,currentCol]!=0) + currentCol
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,currentCol)
}
# 2.2.) Reorganize matrix such that zero vectors are at the bottom, rm parallel vectors
A = swap_Zero_Vectors(A)
A = remove_Parallel_Vectors(A)
# 3.) find potential next pivots and swap rows if exist
currentCol = 2
currentRow = 1
# make loop even easier
for (col in currentCol:nc){
# skip if col is zero
if (all(A[-c(1:currentRow),col] == 0)){
next
}
# go one row down to follow the diagonal if the column is not full of zeros
currentRow = currentRow + 1
# create new pivot
A[currentRow,] = (1/A[currentRow,col]) * A[currentRow,]
# add pivot index
idxPivots = rbind(idxPivots,c(currentRow, col))
# 3.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = col)){
# find nonzero elements in col. vector
idxNonzero = which(A[-c(1:currentRow),col]!=0) + col
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,col)
}
}
# 4.) Now remove all free variable above a pivot
# create matrix containing only the pivots
pivotsVec <- A[idxPivots$i,]
#
nr = nrow(pivotsVec)
# this loop starts with the "lowest" pivot vector (piv) (the one with rightmost pivot)
# and subtracts itself from the next pivot (revPiv) vector such that the free variable
# above the current pivot vector (piv).
for (piv in nr:1){
for (revPiv in piv:1){
if(piv == revPiv){
next
}
A[revPiv,] = A[revPiv,]-A[piv,]*A[revPiv,piv]
}
}
# 5.) set small values to zero
# A = ifelse(abs(A) <= 1e-10, 0, A)
return(A)
}
rref(A)
ref(A)
# clear rref!!
pracma::rref(A)
# full rank - positive
A <- t(matrix(c(3,1,
0,2), nrow = 2))
# clear rref!!
pracma::rref(A)
ref(A)
# rotation - eigenvalues +- i
A <- t(matrix(c(0,-1,
1,0), nrow = 2))
# clear rref!!
pracma::rref(A)
ref(A)
# full rank 5x5
A <- t(matrix(c(1,2,3, 4,-2,
-1,0,1,4,-7,
7,1,-2,4,1,
1,0,10,2,0,
213,1,8,6,4), nrow = 5))
# clear rref!!
pracma::rref(A)
ref(A)
rref(A)
rref <- function(A){
# Corner Case 1: all zero matrix
if (max(abs(A)) == 0){
return(A)
}
# 1.) Setup variables
nc = ncol(A)
nr = nrow(A)
# first pivot must be on first column
currentCol = 1
idxPivots = data.frame(i = 1, j = 1)
# 1.1.) remove parallel vectors
rmIdx = unique(linDep_Cautchy_Schwartz_Matrix(A)$j)
# # 1.2.) set small values to zero
# ifelse(abs(A) <= 1e-10, 0, A)
# put zero-vector and parallel vectors at the bottom
if (!is.null(rmIdx)){
A[rmIdx,] <- rep(0,nc)
A <- add_To_Bottom(A,rmIdx)
}
# 2.) find first pivot (if exists, else normalize first row to first element)
firstPivotIdx = which(A[,1]==1)[1]
# check if a pivot exists?
if (!is.na(firstPivotIdx)){
A <- swap(A,firstPivotIdx,1)
} else {
# Create a pivot (normalize first row)
A[1,] = (1/A[1,1]) * A[1,]
}
# 2.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = currentCol)){
# find nonzero elements in col. vector
idxNonzero = which(A[-1,currentCol]!=0) + currentCol
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,currentCol)
}
# 2.2.) Reorganize matrix such that zero vectors are at the bottom, rm parallel vectors
A = swap_Zero_Vectors(A)
A = remove_Parallel_Vectors(A)
# 3.) find potential next pivots and swap rows if exist
currentCol = 2
currentRow = 1
# make loop even easier
for (col in currentCol:nc){
# skip if col is zero
if (all(A[-c(1:currentRow),col] == 0)){
next
}
# go one row down to follow the diagonal if the column is not full of zeros
currentRow = currentRow + 1
# create new pivot
A[currentRow,] = (1/A[currentRow,col]) * A[currentRow,]
# add pivot index
idxPivots = rbind(idxPivots,c(currentRow, col))
# 3.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = col)){
# find nonzero elements in col. vector
idxNonzero = which(A[-c(1:currentRow),col]!=0) + col
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,col)
}
}
# 4.) Now remove all free variable above a pivot
# create matrix containing only the pivots
pivotsVec <- A[idxPivots$i,]
#
nr = nrow(pivotsVec)
# this loop starts with the "lowest" pivot vector (piv) (the one with rightmost pivot)
# and subtracts itself from the next pivot (revPiv) vector such that the free variable
# above the current pivot vector (piv).
for (piv in nr:1){
for (revPiv in piv:1){
if(piv == revPiv){
next
}
A[revPiv,] = A[revPiv,]-A[piv,]*A[revPiv,piv]
}
}
# 5.) set small values to zero
A = ifelse(abs(A) <= 1e-10, 0, A)
return(A)
}
# clear rref!!
pracma::rref(A)
rref(A)
# full rank 5x5
A <- t(matrix(c(1,2,3, 4,-2,
-1,0,1,4,-7,
7,1,-2,4,1,
1,0,10,2,0,
213,1,8,6,4), nrow = 5))
# clear rref!!
pracma::rref(A)
rref(A)
# lin dep rect
A <- t(matrix(c(1,2,3,4,
1,2,3,4,
1,2,3,4,
1,2,3,4,
-1,0,1,-3,
7,1,-2,-3), nrow = 4))
# clear rref!!
pracma::rref(A)
rref(A)
# rotation - eigenvalues +- i
A <- t(matrix(c(0,-1,
1,0), nrow = 2))
# clear rref!!
pracma::rref(A)
rref(A)
# rotation - eigenvalues +- i
A <- t(matrix(c(0,-1,
1,0), nrow = 2))
# clear rref!!
pracma::rref(A)
rref(A)
# zero
A <- t(matrix(c(0,0,
0,0), nrow = 2))
# clear rref!!
pracma::rref(A)
rref(A)
# symmetric + pos def
A <- t(matrix(c(2,2,1,
2,5,1,
1,1,2), nrow = 3))
# clear rref!!
pracma::rref(A)
rref(A)
# full rank 3x3
A <- t(matrix(c(1,2,3,
-1,0,1,
7,1,-2), nrow = 3))
# clear rref!!
pracma::rref(A)
rref(A)
# full rank 3x3
A <- t(matrix(c(1,2,3,
-1,0,1,
7,1,-2), nrow = 3))
# lin dep 3x3 (Row 1 + Row 2 == Row 3)
A <- t(matrix(c(2,2,2,
-2,2,-2,
0,4,0), nrow = 3))
# clear rref!!
pracma::rref(A)
rref(A)
