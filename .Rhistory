v = c(2,2,4)
linDep_Cautchy_Schwartz(rbind(u,v))
rbind(u,v)
u = c(1,1,2)
v = c(2,2,4)
p = c(4,4,8)
linDep_Cautchy_Schwartz(rbind(u,v))
linDep_Cautchy_Schwartz(cbind(u,v))
u = c(1,1,2)
v = c(2,2,4)
u = c(1,1,2)
v = c(2,2,4)
p = c(4,4,8)
linDep_Cautchy_Schwartz(cbind(u,v,p))
linDep_Cautchy_Schwartz_Matrix <- function(u,v){
# Consists of checking whether <u,v> >= ||u|| ||v||
# Strict equality indicate linear dependence, i.e. <u,v> = ||u|| ||v||
# By transposing the matrix here, the algo needs to know whether the idx
# output is meant for the row or col space!!!
# # Check whether there are more rows or cols, then choose shorter space
# # This reduces the # of iterations in the double loop
# if(ncol(A) > nrow(A)){
#   A = t(A)
# }
# compute norms and dot prod of the span of the row/col space
u_norm = sqrt(sum(u^2))
v_norm = sqrt(sum(v^2))
u_v = v %*% u
# check for strict equality to find lin. dependent rows/cols
if (u_v == u_norm * v_norm ){
return(FALSE)
} else {
return(TRUE)
}
}
linDep_Cautchy_Schwartz <- function(u,v){
# Consists of checking whether <u,v> >= ||u|| ||v||
# Strict equality indicate linear dependence, i.e. <u,v> = ||u|| ||v||
# By transposing the matrix here, the algo needs to know whether the idx
# output is meant for the row or col space!!!
# # Check whether there are more rows or cols, then choose shorter space
# # This reduces the # of iterations in the double loop
# if(ncol(A) > nrow(A)){
#   A = t(A)
# }
# compute norms and dot prod of the span of the row/col space
u_norm = sqrt(sum(u^2))
v_norm = sqrt(sum(v^2))
u_v = v %*% u
# check for strict equality to find lin. dependent rows/cols
if (u_v == u_norm * v_norm ){
return(FALSE)
} else {
return(TRUE)
}
}
u
v
linDep_Cautchy_Schwartz(u,v)
linDep_Cautchy_Schwartz <- function(u,v){
# Consists of checking whether <u,v> >= ||u|| ||v||
# Strict equality indicate linear dependence, i.e. <u,v> = ||u|| ||v||
# By transposing the matrix here, the algo needs to know whether the idx
# output is meant for the row or col space!!!
# # Check whether there are more rows or cols, then choose shorter space
# # This reduces the # of iterations in the double loop
# if(ncol(A) > nrow(A)){
#   A = t(A)
# }
# compute norms and dot prod of the span of the row/col space
u_norm = sqrt(sum(u^2))
v_norm = sqrt(sum(v^2))
u_v = v %*% u
print(u_v)
print(u_norm * v_norm)
# check for strict equality to find lin. dependent rows/cols
if (u_v == u_norm * v_norm ){
return(FALSE)
} else {
return(TRUE)
}
}
linDep_Cautchy_Schwartz(u,v)
linDep_Cautchy_Schwartz <- function(u,v){
# Consists of checking whether <u,v> >= ||u|| ||v||
# Strict equality indicate linear dependence, i.e. <u,v> = ||u|| ||v||
# By transposing the matrix here, the algo needs to know whether the idx
# output is meant for the row or col space!!!
# # Check whether there are more rows or cols, then choose shorter space
# # This reduces the # of iterations in the double loop
# if(ncol(A) > nrow(A)){
#   A = t(A)
# }
# compute norms and dot prod of the span of the row/col space
u_norm = sqrt(sum(u^2))
v_norm = sqrt(sum(v^2))
u_v = v %*% u
print(u_v)
print(u_norm * v_norm)
print(u_v == u_norm * v_norm)
# check for strict equality to find lin. dependent rows/cols
if (u_v == u_norm * v_norm ){
return(FALSE)
} else {
return(TRUE)
}
}
linDep_Cautchy_Schwartz(u,v)
u_norm = sqrt(sum(u^2))
v_norm = sqrt(sum(v^2))
u_v = v %*% u
print(u_v)
print(u_norm * v_norm)
u_v
u_v = v * u
u_v
u_norm = sqrt(sum(u^2))
v_norm = sqrt(sum(v^2))
u_v = numeric(v %*% u)
print(u_v)
u_v
u_v = v %*% u
u_v
u_v = drop(v %*% u)
u_v
print(u_norm * v_norm)
print(u_v == u_norm * v_norm)
u_v
u_norm * v_norm
print(u_v == u_norm * v_norm)
print(12 == 12)
u_norm = sqrt(sum(u^2))
v_norm = sqrt(sum(v^2))
u_v = drop(v %*% u)
print(u_v)
print(u_norm * v_norm)
print(u_v == u_norm * v_norm)
str(u_v)
str(u_norm * v_norm)
u_v
u_norm * v_norm
print(u_v == u_norm * v_norm)
diag(2)
print(u_v == u_norm * v_norm)
x = u_norm * v_norm
u_v == u_norm * v_norm
print(u_v == x)
u_v
x
print(u_v != x)
u_norm
v_norm
u_norm = sqrt(sum(u^2))
v_norm = sqrt(sum(v^2))
u_v_norm = u_norm * v_norm
u_v = drop(v %*% u)
tol = 1e-5
(u_v-u_v_norm) >= (0.05-tol)
u_v-u_v_norm
(u_v-u_v_norm) >= (tol)
u_v-u_v_norm
abs(u_v-u_v_norm) >= (tol)
abs(u_v-u_v_norm) <= (tol)
tol = 1e-5
abs(u_v-u_v_norm) <= tol
linDep_Cautchy_Schwartz(u,v)
linDep_Cautchy_Schwartz <- function(u,v, tol = 1e-05){
# Consists of checking whether <u,v> >= ||u|| ||v||
# Strict equality indicate linear dependence, i.e. <u,v> = ||u|| ||v||
# By transposing the matrix here, the algo needs to know whether the idx
# output is meant for the row or col space!!!
# # Check whether there are more rows or cols, then choose shorter space
# # This reduces the # of iterations in the double loop
# if(ncol(A) > nrow(A)){
#   A = t(A)
# }
# compute norms of the vectors
u_norm = sqrt(sum(u^2))
v_norm = sqrt(sum(v^2))
u_v_norm = u_norm * v_norm
# dot product of vectors
u_v = drop(v %*% u)
# check for strict equality to find lin. dependent rows/cols
if (abs(u_v-u_v_norm) <= tol){
return(FALSE)
} else {
return(TRUE)
}
}
linDep_Cautchy_Schwartz(u,v)
isPosDef <- function(A){# test 1 - symmetry
test1 = all(round(A, 5) == round(t(A),5))
# test 2 - positive eigenvalues
test2 = prod(eigen(A)$value) > 0
# test 3 - positive upper left submatrices
dimA = nrow(A)
upLeftDets = c(A[1,1])
if (A[1,1] < 0){
test3 = FALSE
} else {
for (i in 2:dimA){
upLeftDet = det(A[1:i,1:i])
if (upLeftDet < 0){
test3 = FALSE
} else {
upLeftDets = c(upLeftDets,det(A[1:i,1:i]))
}
}
}
test3 = all(upLeftDets > 0)
return(all(test1,test2,test3))
}
isPosDef <- function(A){# test 1 - symmetry
# test 1 - is symmetric?
test1 = all(round(A, 5) == round(t(A),5))
message("Test 1 - Matrix is symmetric? ", test1)
# test 2 - positive eigenvalues
test2 = prod(eigen(A)$value) > 0
message("Test 2 - All eigenvalues are positive? ", test2)
# test 3 - positive upper left submatrices
dimA = nrow(A)
upLeftDets = c(A[1,1])
if (A[1,1] < 0){
test3 = FALSE
} else {
for (i in 2:dimA){
upLeftDet = det(A[1:i,1:i])
if (upLeftDet < 0){
test3 = FALSE
} else {
upLeftDets = c(upLeftDets,det(A[1:i,1:i]))
}
}
}
test3 = all(upLeftDets > 0)
message("Test 3 - Determinant of upper left submatrices are > 0? ", test3)
return(all(test1,test2,test3))
}
isPosDef <- function(A){# test 1 - symmetry
# test 1 - is symmetric?
test1 = all(round(A, 5) == round(t(A),5))
message("Test 1 - Matrix is symmetric? ", test1)
# test 2 - positive eigenvalues
test2 = prod(eigen(A)$value) > 0
message("Test 2 - All eigenvalues are positive? ", test2)
# test 3 - positive upper left submatrices
dimA = nrow(A)
upLeftDets = c(A[1,1])
if (A[1,1] < 0){
test3 = FALSE
} else {
for (i in 2:dimA){
upLeftDet = det(A[1:i,1:i])
if (upLeftDet < 0){
test3 = FALSE
} else {
upLeftDets = c(upLeftDets,det(A[1:i,1:i]))
}
}
}
test3 = all(upLeftDets > 0)
message("Test 3 - Determinant of upper left submatrices are > 0? ", test3)
# output
return(all(test1,test2,test3))
}
# symmetric + pos def
A <- t(matrix(c(2,2,1,
2,5,1,
1,1,2), nrow = 3))
isPosDef(A)
# from p.126 (matrix book) --> works for UDU-1
A <- t(matrix(c(-1,-2,-2,
1,2,1,
-1,-1,-1), nrow = 3))
isPosDef(A)
# full rank 5x5
A <- t(matrix(c(1,2,3, 4,-2,
-1,0,1,4,-7,
7,1,-2,4,1,
1,0,10,2,0,
213,1,8,6,4), nrow = 5))
isPosDef(A)
isPosDef <- function(A){# test 1 - symmetry
# test 1 - is symmetric?
test1 = all(round(A, 5) == round(t(A),5))
message("Test 1 - Matrix is symmetric? ", test1)
# test 2 - positive eigenvalues
test2 = prod(Re(eigen(A)$value)) > 0
message("Test 2 - All (real) eigenvalues are positive? ", test2)
# test 3 - positive upper left submatrices
dimA = nrow(A)
upLeftDets = c(A[1,1])
if (A[1,1] < 0){
test3 = FALSE
} else {
for (i in 2:dimA){
upLeftDet = det(A[1:i,1:i])
if (upLeftDet < 0){
test3 = FALSE
} else {
upLeftDets = c(upLeftDets,det(A[1:i,1:i]))
}
}
}
test3 = all(upLeftDets > 0)
message("Test 3 - Determinant of upper left submatrices are > 0? ", test3)
# output
return(all(test1,test2,test3))
}
isPosDef(A)
sample(dim,2)
sample(0:9,2)
det(cbind(v1,sample(0:9,dim)))
v1 = sample(0:9,dim)
det(cbind(v1,sample(0:9,dim)))
v1 = sample(0:9,dim)
v1 = sample(0:9,dim)
dim = 2
v1 = sample(0:9,dim)
cbind(v1,sample(0:9,dim))
det(cbind(v1,sample(0:9,dim)))
det(cbind(v1,sample(0:9,dim)))
det(cbind(v1,sample(0:9,dim)))
det(cbind(v1,sample(0:9,dim)))
det(cbind(v1,sample(0:9,dim)))
det(cbind(v1,sample(0:9,dim)))
det(cbind(v1,sample(0:9,dim)))
det(cbind(v1,sample(0:9,dim)))
dim = 2
v1 = sample(0:9,dim)
basis = det(cbind(v1,sample(0:9,dim)))
while (basis != 0){
basis = det(cbind(v1,sample(0:9,dim)))
}
basis
basis
dim = 2
v1 = sample(0:9,dim)
basis = cbind(v1,sample(0:9,dim))
while (det(basis) != 0){
basis = cbind(v1,sample(0:9,dim))
}
basis
dim = 2
v1 = sample(0:9,dim)
basis = cbind(v1,sample(0:9,dim))
while (det(basis) == 0){
basis = cbind(v1,sample(0:9,dim))
}
basis
rank_Matrix(basis)
dim = 2
v1 = sample(0:9,dim)
basis = cbind(v1,sample(0:9,dim))
while (det(basis) == 0){
basis = cbind(v1,sample(0:9,dim))
}
# output
out = list()
for (rowcol in 1:dim){
out[[rowcol]] = basis[,rowcol]
}
dim = 2
v1 = sample(0:9,dim)
basis = cbind(v1,sample(0:9,dim))
while (det(basis) == 0){
basis = cbind(v1,sample(0:9,dim))
}
# output
out = list()
for (rowcol in 1:dim){
out[[rowcol]] = basis[,rowcol]
}
out
create_basis <- function(dim, lower = 0, upper = 9){
v1 = sample(lower:upper,dim)
basis = cbind(v1,sample(lower:upper,dim))
while (det(basis) == 0){
basis = cbind(v1,sample(lower:upper,dim))
}
# output list of vecs instead of matrix
out = list()
for (rowcol in 1:dim){
out[[rowcol]] = basis[,rowcol]
}
return(out)
}
create_basis(3)
create_basis <- function(dim, lower = 0, upper = 9){
v1 = sample(lower:upper,dim)
basis = cbind(v1,sample(lower:upper,dim))
for (v in 1:dim){
basis = cbind(basis,sample(lower:upper,dim))
while (det(basis) == 0){
basis = cbind(basis,sample(lower:upper,dim))
}
}
# output list of vecs instead of matrix
out = list()
for (rowcol in 1:dim){
out[[rowcol]] = basis[,rowcol]
}
return(out)
}
create_basis(3)
dim = 3
v1 = sample(lower:upper,dim)
lower = 0
upper = 9
dim = 3
v1 = sample(lower:upper,dim)
basis = cbind(v1,sample(lower:upper,dim))
for (v in 1:dim){
basis = cbind(basis,sample(lower:upper,dim))
while (det(basis) == 0){
basis = cbind(basis,sample(lower:upper,dim))
}
}
matrix(sample(lower:upper,dim^2), nrow = dim)
det(matrix(sample(lower:upper,dim^2), nrow = dim))
det(matrix(sample(lower:upper,dim^2), nrow = dim))
det(matrix(sample(lower:upper,dim^2), nrow = dim))
det(matrix(sample(lower:upper,dim^2), nrow = dim))
det(matrix(sample(lower:upper,dim^2), nrow = dim))
det(matrix(sample(lower:upper,dim^2), nrow = dim))
det(matrix(sample(lower:upper,dim^2), nrow = dim))
det(matrix(sample(lower:upper,dim^2), nrow = dim))
det(matrix(sample(lower:upper,dim^2), nrow = dim))
det(matrix(sample(lower:upper,dim^2), nrow = dim))
det(matrix(sample(lower:upper,dim^2), nrow = dim))
det(matrix(sample(lower:upper,dim^2), nrow = dim))
det(matrix(sample(lower:upper,dim^2), nrow = dim))
det(matrix(sample(lower:upper,dim^2), nrow = dim))
det(matrix(sample(lower:upper,dim^2), nrow = dim))
det(matrix(sample(lower:upper,dim^2), nrow = dim))
det(matrix(sample(lower:upper,dim^2), nrow = dim))
det(matrix(sample(lower:upper,dim^2), nrow = dim))
det(matrix(sample(lower:upper,dim^2), nrow = dim))
create_basis <- function(dim, lower = 0, upper = 9){
basis = matrix(sample(lower:upper,dim^2), nrow = dim)
while (det(basis) == 0){
basis = matrix(sample(lower:upper,dim^2), nrow = dim)
}
# output list of vecs instead of matrix
out = list()
for (rowcol in 1:dim){
out[[rowcol]] = basis[,rowcol]
}
return(out)
}
create_basis(3)
create_basis <- function(dim, lower = 0, upper = 9){
basis = matrix(sample(lower:upper,dim^2), nrow = dim)
while (det(basis) == 0){
basis = matrix(sample(lower:upper,dim^2), nrow = dim)
}
return(basis)
# output list of vecs instead of matrix
out = list()
for (rowcol in 1:dim){
out[[rowcol]] = basis[,rowcol]
}
return(out)
}
create_basis(3)
create_basis(3)
create_basis(3)
create_basis(3)
create_basis(3)
rank(create_basis(3))
rank(create_basis(3))
rank_Matrix(create_basis(3))
rank_Matrix(create_basis(3))
rank_Matrix(create_basis(3))
rank_Matrix(create_basis(3))
rank_Matrix(create_basis(3))
rank_Matrix(create_basis(3))
rank_Matrix(create_basis(3))
rank_Matrix(create_basis(3))
rank_Matrix(create_basis(3))
rank_Matrix(create_basis(3))
rank_Matrix(create_basis(3))
rank_Matrix(create_basis(3))
rank_Matrix(create_basis(3))
rank_Matrix(create_basis(3))
rank_Matrix(create_basis(3))
rank_Matrix(create_basis(3))
rank_Matrix(create_basis(3))
rank_Matrix(create_basis(3))
rank_Matrix(create_basis(3))
rank_Matrix(create_basis(3))
rank_Matrix(create_basis(3))
rank_Matrix(create_basis(3))
rank_Matrix(create_basis(3))
rank_Matrix(create_basis(3))
rank_Matrix(create_basis(3))
rank_Matrix(create_basis(3))
rank_Matrix(create_basis(3))
rank_Matrix(create_basis(3))
rank_Matrix(create_basis(3))
rank_Matrix(create_basis(3))
orthogonalize <- function(A){
preQ = A%*%t(A)
Q = eigen(preQ, symmetric = T)$vectors
for (row in 1:nrow(Q)){
# Normalize Rows
Q[row,] = 1/sqrt(c(Q[row,]%*%Q[row,]))*c(Q[row,])
}
return(Q)
}
orthogonalize(A)
A%*%orthogonalize(A)
