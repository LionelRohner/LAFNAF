all_Penrose_check = F,
digits = 2){
message("Disclaimer: All matrices are transformed to pure integer matrices first, so consider that...\n")
if (all_Penrose_check == F){
Penrose_1 = all(round(A%*%G%*%A,2) == A)
message("AGA=A is ", Penrose_1)
return(Penrose_1)
} else{
Penrose_1 = all(round(A%*%G%*%A) == A)
message("AGA = A is ", Penrose_1)
Penrose_2 = all(round(G%*%A%*%G,digits = digits) == round(G,digits = digits))
message("GAG = G is ", Penrose_2)
Penrose_3 = all(round(A%*%G) == t(round(A%*%G)))
message("AG = (AG)' is ", Penrose_3)
Penrose_4 = all(round(G%*%A) == t(round(G%*%A)))
message("GA = (GA)' is ", Penrose_4)
return(all(Penrose_1,Penrose_2,Penrose_3,Penrose_4))
}
}
G <- generalized_Inverse(A)
check_Penrose_Cond(A,G, all_Penrose_check = T)
round(G%*%A%*%G,2) == round(G,2)
A <- t(matrix(c(2,2,2,
-2,2,-2,
0,4,0), nrow = 3))
rank_Matrix <- function(A, tol = 1e-12){
return(sum(eigen(A)$values > tol))
#
# # if A is mxn with m != n, then the larger (be it rows or cols) will be lin dep!
# if (ncol(A) > nrow(A)){
#   A = t(A)
# }
#
# # lin.dep indices
# CS_indices <- unique(linDep_Cautchy_Schwartz(A)$j)
# print(CS_indices)
# # if CS_indices is empty, A is full-rank, hence rank = nrow(A) = ncol(A)
# if (is.null(CS_indices)){
#   message("Matrix is full-rank!")
#   return(nrow(A))
# } else {
#   # not full rank situation, due to transposition, nrow(A) > ncol(A)
#   rank = nrow(A)-length(CS_indices)
#   message("Matrix has order ", nrow(A),"x",ncol(A), " and rank ", rank)
#   return(rank)
# }
}
rank_Matrix(A)
A <- t(matrix(c(2,2,2,
-2,2,-2,
0,4,0), nrow = 3))
rank_Matrix <- function(A, tol = 1e-12){
# return(sum(eigen(A)$values > tol))
# if A is mxn with m != n, then the larger (be it rows or cols) will be lin dep!
if (ncol(A) > nrow(A)){
A = t(A)
}
# lin.dep indices
CS_indices <- unique(linDep_Cautchy_Schwartz(A)$j)
print(CS_indices)
# if CS_indices is empty, A is full-rank, hence rank = nrow(A) = ncol(A)
if (is.null(CS_indices)){
message("Matrix is full-rank!")
return(nrow(A))
} else {
# not full rank situation, due to transposition, nrow(A) > ncol(A)
rank = nrow(A)-length(CS_indices)
message("Matrix has order ", nrow(A),"x",ncol(A), " and rank ", rank)
return(rank)
}
}
rank_Matrix(A)
A[1,]+A[2,]
A[1,]+A[2,]==A[3,]
A <- t(matrix(c(2,2,2,
-2,2,-2,
0,4,0), nrow = 3))
P = A%*%t(A)
P
P = A%*%t(A)
P
A <- t(matrix(c(1,-3,5,
0,1,7,
2,-4,28,
3,-13,0,
4,-14,-3,
5,-9,30,
6,2,173), nrow = 3))
P = A%*%t(A)
P
A <- t(matrix(c(2,2,2,
-2,2,-2,
0,4,0), nrow = 3))
P = A%*%t(A)
P[row,]%*%P[row,]
P = A%*%t(A)
row = 1
P[row,]
P[row,]%*%P[row,]
t(P[row,])%*%P[row,]
P = A%*%t(A)
row = 1
for (row in 1:nrow(P)){
P[row,] = sqrt(P[row,]%*%P[row,])*P[row,]
}
P[row,] = sqrt(P[row,]%*%P[row,])*P[row,]
sqrt(P[row,]%*%P[row,])
P[row,]%*%P[row,]
P = A%*%t(A)
row = 1
P[row,]%*%P[row,]
sqrt(P[row,]%*%P[row,])
1/sqrt(P[row,]%*%P[row,])*P[row,]
P[row,] = as.vector(1/sqrt(P[row,]%*%P[row,])*P[row,])
P[row,] = 1/sqrt(P[row,]%*%P[row,])*c(P[row,])
P[row,] = 1/sqrt(c(P[row,]%*%P[row,]))*c(P[row,])
1/sqrt(c(P[row,]%*%P[row,]))*c(P[row,])
P = A%*%t(A)
for (row in 1:nrow(P)){
P[row,] = 1/sqrt(c(P[row,]%*%P[row,]))*c(P[row,])
}
P
P%*%t(P)
t(P)%*%P
sqrt(sum(P[1,]))
sum(P[1,])
sqrt(sum(P[1,]))
P = A%*%t(A)
sqrt(sum(P[1,]))
P[1,]
sum(P[1,])
c(P[row,]%*%P[row,])
P[row,] = 1/sqrt(P[row,]%*%P[row,])*c(P[row,])
sqrt(P[1,])
P = A%*%t(A)
sqrt(P[1,])
P[1,]
sqrt(sum(P[1,]^2))
P = A%*%t(A)
for (row in 1:nrow(P)){
# Normalize Rows
P[row,] = 1/sqrt(c(P[row,]%*%P[row,]))*c(P[row,])
}
sqrt(sum(P[1,]^2))
P
P%*%t(P)
preP = eigen(preP)
preP = A%*%t(A)
preP = eigen(preP)
preP
preP = eigen(preP)$vectors
preP = A%*%t(A)
P = eigen(preP)$vectors
for (row in 1:nrow(P)){
# Normalize Rows
P[row,] = 1/sqrt(c(P[row,]%*%P[row,]))*c(P[row,])
}
P
P%*%t(P)
round(P%*%t(P))
orthogonalize <- function(A){
preQ = A%*%t(A)
Q = eigen(preQ)$vectors
for (row in 1:nrow(Q)){
# Normalize Rows
Q[row,] = 1/sqrt(c(Q[row,]%*%Q[row,]))*c(Q[row,])
}
return(Q)
}
orthogonalize(A)
Q <- orthogonalize(A)
Q <- orthogonalize(A)
Q%*%t(Q)
orthogonalize <- function(A){
preQ = A%*%t(A)
Q = eigen(preQ)$vectors
for (row in 1:nrow(Q)){
# Normalize Rows
Q[row,] = 1/sqrt(c(Q[row,]%*%Q[row,]))*c(Q[row,])
}
Q <- ifelse(Q < 1e-14, 0, Q)
return(Q)
}
Q <- orthogonalize(A)
Q
Q%*%t(Q)
orthogonalize <- function(A){
preQ = A%*%t(A)
Q = eigen(preQ)$vectors
for (row in 1:nrow(Q)){
# Normalize Rows
Q[row,] = 1/sqrt(c(Q[row,]%*%Q[row,]))*c(Q[row,])
}
return(Q)
}
Q <- orthogonalize(A)
eigenVal <- eigen(Q)$values
eigenVal
eigenVal <- eigen(P)$values
eigenVal
rank_Matrix <- function(A, tol = 1e-12){
return(sum(eigen(A)$values > tol))
# # if A is mxn with m != n, then the larger (be it rows or cols) will be lin dep!
# if (ncol(A) > nrow(A)){
#   A = t(A)
# }
#
# # lin.dep indices
# CS_indices <- unique(linDep_Cautchy_Schwartz(A)$j)
# print(CS_indices)
# # if CS_indices is empty, A is full-rank, hence rank = nrow(A) = ncol(A)
# if (is.null(CS_indices)){
#   message("Matrix is full-rank!")
#   return(nrow(A))
# } else {
#   # not full rank situation, due to transposition, nrow(A) > ncol(A)
#   rank = nrow(A)-length(CS_indices)
#   message("Matrix has order ", nrow(A),"x",ncol(A), " and rank ", rank)
#   return(rank)
# }
}
rank_Matrix(A)
rank_Matrix <- function(A, tol = 1e-12){
return(sum(eigen(A)$values > tol))
return(eigen(A))
# # if A is mxn with m != n, then the larger (be it rows or cols) will be lin dep!
# if (ncol(A) > nrow(A)){
#   A = t(A)
# }
#
# # lin.dep indices
# CS_indices <- unique(linDep_Cautchy_Schwartz(A)$j)
# print(CS_indices)
# # if CS_indices is empty, A is full-rank, hence rank = nrow(A) = ncol(A)
# if (is.null(CS_indices)){
#   message("Matrix is full-rank!")
#   return(nrow(A))
# } else {
#   # not full rank situation, due to transposition, nrow(A) > ncol(A)
#   rank = nrow(A)-length(CS_indices)
#   message("Matrix has order ", nrow(A),"x",ncol(A), " and rank ", rank)
#   return(rank)
# }
}
rank_Matrix(A)
rank_Matrix <- function(A, tol = 1e-12){
# return(sum(eigen(A)$values > tol))
return(eigen(A))
# # if A is mxn with m != n, then the larger (be it rows or cols) will be lin dep!
# if (ncol(A) > nrow(A)){
#   A = t(A)
# }
#
# # lin.dep indices
# CS_indices <- unique(linDep_Cautchy_Schwartz(A)$j)
# print(CS_indices)
# # if CS_indices is empty, A is full-rank, hence rank = nrow(A) = ncol(A)
# if (is.null(CS_indices)){
#   message("Matrix is full-rank!")
#   return(nrow(A))
# } else {
#   # not full rank situation, due to transposition, nrow(A) > ncol(A)
#   rank = nrow(A)-length(CS_indices)
#   message("Matrix has order ", nrow(A),"x",ncol(A), " and rank ", rank)
#   return(rank)
# }
}
rank_Matrix(A)
A <- t(matrix(c(2,2,2,
-2,2,-2,
0,4,0), nrow = 3))
rank_Matrix <- function(A, tol = 1e-12){
# return(sum(eigen(A)$values > tol))
return(eigen(A)$values)
# # if A is mxn with m != n, then the larger (be it rows or cols) will be lin dep!
# if (ncol(A) > nrow(A)){
#   A = t(A)
# }
#
# # lin.dep indices
# CS_indices <- unique(linDep_Cautchy_Schwartz(A)$j)
# print(CS_indices)
# # if CS_indices is empty, A is full-rank, hence rank = nrow(A) = ncol(A)
# if (is.null(CS_indices)){
#   message("Matrix is full-rank!")
#   return(nrow(A))
# } else {
#   # not full rank situation, due to transposition, nrow(A) > ncol(A)
#   rank = nrow(A)-length(CS_indices)
#   message("Matrix has order ", nrow(A),"x",ncol(A), " and rank ", rank)
#   return(rank)
# }
}
rank_Matrix(A)
rank_Matrix <- function(A, tol = 1e-12){
# return(sum(eigen(A)$values > tol))
return(eigen(A)$values)
# # if A is mxn with m != n, then the larger (be it rows or cols) will be lin dep!
# if (ncol(A) > nrow(A)){
#   A = t(A)
# }
#
# # lin.dep indices
# CS_indices <- unique(linDep_Cautchy_Schwartz(A)$j)
# print(CS_indices)
# # if CS_indices is empty, A is full-rank, hence rank = nrow(A) = ncol(A)
# if (is.null(CS_indices)){
#   message("Matrix is full-rank!")
#   return(nrow(A))
# } else {
#   # not full rank situation, due to transposition, nrow(A) > ncol(A)
#   rank = nrow(A)-length(CS_indices)
#   message("Matrix has order ", nrow(A),"x",ncol(A), " and rank ", rank)
#   return(rank)
# }
}
rank_Matrix(A)
e <- rank_Matrix(A)
e
Im(e)
Real(e)
R(e)
Im(e)-e
e-Im(e)
Re(e)
rank_Matrix <- function(A, tol = 1e-12){
return(sum(Re(eigen(A)$values) > tol))
# # if A is mxn with m != n, then the larger (be it rows or cols) will be lin dep!
# if (ncol(A) > nrow(A)){
#   A = t(A)
# }
#
# # lin.dep indices
# CS_indices <- unique(linDep_Cautchy_Schwartz(A)$j)
# print(CS_indices)
# # if CS_indices is empty, A is full-rank, hence rank = nrow(A) = ncol(A)
# if (is.null(CS_indices)){
#   message("Matrix is full-rank!")
#   return(nrow(A))
# } else {
#   # not full rank situation, due to transposition, nrow(A) > ncol(A)
#   rank = nrow(A)-length(CS_indices)
#   message("Matrix has order ", nrow(A),"x",ncol(A), " and rank ", rank)
#   return(rank)
# }
}
rank_Matrix(A)
D <- diag(eigneVal)
?diag
D <- matrix(nrow = sum(eigenVal), ncol = sum(eigenVal))
eigenVal <- eigen(P)$values
D <- matrix(nrow = sum(eigenVal), ncol = sum(eigenVal))
D <- matrix(nrow = length(eigenVal), ncol = length(eigenVal))
D
D <- matrix(0,nrow = length(eigenVal), ncol = length(eigenVal))
D
diag(D) <- eigenVal
D
eigenVal
P%*%D%*%t(Q)
# create P
P <- orthogonalize(A)
# create Q
Q <- orthogonalize(t(A))
eigenVal <- eigen(P)$values
D <- matrix(0,nrow = length(eigenVal), ncol = length(eigenVal))
diag(D) <- eigenVal
P%*%D%*%t(Q)
diag(D) <- sqrt(eigenVal)
P%*%D%*%t(Q)
# create P
P <- orthogonalize(A)
# create Q
Q <- orthogonalize(t(A))
eigenVal <- eigen(P)$values
D <- matrix(0,nrow = length(eigenVal), ncol = length(eigenVal))
diag(D) <- sqrt(eigenVal)
P%*%D%*%t(Q)
log2(1.25)
A <- t(matrix(c(1,2,3, 4,-2,
-1,0,1,4,-7,
7,1,-2,4,1,
1,0,10,2,0,
213,1,8,6,4), nrow = 5))
eigen(A)
A <- t(matrix(c(1,2,3,
-1,0,1,
7,1,-2), nrow = 3))
eigen(A)
# lin dep 3x3
A <- t(matrix(c(2,2,2,
-2,2,-2,
0,4,0), nrow = 3))
eigen(A)
# lin dep 3x3
A <- t(matrix(c(2,2,2,
-2,2,-2,
0,4,0), nrow = 3))
eigen(A)
rel(eigen(A)$value)
Re(eigen(A)$value)
A[1,]+A[2,]
function(A){
preQ = A%*%t(A)
Q = eigen(preQ)$vectors
for (row in 1:nrow(Q)){
# Normalize Rows
Q[row,] = 1/sqrt(c(Q[row,]%*%Q[row,]))*c(Q[row,])
}
return(Q)
}
# create P
P <- orthogonalize(A)
P
P%*% t(P)
svd(A)
P
P[,1:2] = P[,1:2] * -1
P
svd(A)
P
P
# create Q
Q <- orthogonalize(t(A))
Q
eigenVal <- eigen(P)$values
D <- matrix(0,nrow = length(eigenVal), ncol = length(eigenVal))
diag(D) <- sqrt(eigenVal)
P%*%D%*%t(Q)
D
Re(D)
D = Re(D)
P%*%D%*%t(Q)
D
eigenVal <- eigen(P)$values
D <- matrix(0,nrow = length(eigenVal), ncol = length(eigenVal))
diag(D) <- sqrt(eigenVal)
D
# full rank 3x3
A <- t(matrix(c(1,2,3,
-1,0,1,
7,1,-2), nrow = 3))
svd(A)
# create P
P <- orthogonalize(A)
P
P[,2:3] = P[,2:3] * -1
P
P
svd(A)
svd(A)$u
P
# create Q
Q <- orthogonalize(t(A))
svd(A)$v
Q
Q <- Q*-1
Q
eigenVal <- eigen(P)$values
eigenVal
D <- matrix(0,nrow = length(eigenVal), ncol = length(eigenVal))
diag(D) <- sqrt(eigenVal)
P%*%D%*%t(Q)
eigenVal <- eigen(A%*%t(A))$values
D <- matrix(0,nrow = length(eigenVal), ncol = length(eigenVal))
diag(D) <- sqrt(eigenVal)
P%*%D%*%t(Q)
# create P
P <- orthogonalize(A)
# create Q
Q <- orthogonalize(t(A))
eigenVal <- eigen(A%*%t(A))$values
D <- matrix(0,nrow = length(eigenVal), ncol = length(eigenVal))
diag(D) <- sqrt(eigenVal)
P%*%D%*%t(Q)
?eigen
orthogonalize <- function(A){
preQ = A%*%t(A)
Q = eigen(preQ, symmetric = T)$vectors
for (row in 1:nrow(Q)){
# Normalize Rows
Q[row,] = 1/sqrt(c(Q[row,]%*%Q[row,]))*c(Q[row,])
}
return(Q)
}
# full rank 3x3
A <- t(matrix(c(1,2,3,
-1,0,1,
7,1,-2), nrow = 3))
# create P
P <- orthogonalize(A)
# create Q
Q <- orthogonalize(t(A))
eigenVal <- eigen(A%*%t(A))$values
D <- matrix(0,nrow = length(eigenVal), ncol = length(eigenVal))
diag(D) <- sqrt(eigenVal)
P%*%D%*%t(Q)
# Q <- Q*-1
Q
svd(A)$v
P%*%D%*%t(Q)
svd(A)
v <- svd(A)
svd(A)
svd(A)
res <- list()
res <- list(P,D,Q)
res
res <- list(P,diag(D),Q)
res
res <- list(P = P,D = D, Q = Q)
res
