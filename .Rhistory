return(NULL)
}
W <- A[idxRow, idxCol]
}
# check assumptions for non-singularity
if (det(W) == 0){
message("Hope that never happens ;)")
return(NULL)
}
### step 2 : (W^-1)^T
message("Step 2 : (W^-1)^T!")
# create adjoint matrix - adjoint() doesnt work for 2x2
if (dim(W)[1] == 2){
adj_W = -1*W
diag(adj_W) = rev(diag(W))
} else {
adj_W = adjugate(W)
}
transp_inv_W <- t(adj_W/det(W))
### step 3 : replace elements of A with (W^-1)^T
message("Step 3 : Project rows/cols of (W^-1)^T into a a zero matrix A0 of order dim(A)!")
# Again, if A is non-singular from scratch skip Step 3
if (nc == nr && det(A) != 0){
A0 = transp_inv_W
} else{
A0 <- 0*A
A0[idxRow,idxCol] = transp_inv_W
}
### step 4 : t(A)
message("Step 3 : G = A0^T!")
G <- t(A0)
return(G)
}
A%*%MASS::ginv(A)%*%A
A%*%generalized_Inverse(A)%*%A
generalized_Inverse(A)
generalized_Inverse(A)
A%*%generalized_Inverse(A)%*%A
generalized_Inverse <- function(A){
### step 1 : Find a LIN submatrix of order rxr
message("Step 1 : Find a LIN submatrix W of order rxr in A!")
nc = ncol(A)
nr = nrow(A)
rank = rank_Matrix(A)
# Check whether A is full rank anyways
if (nc == nr && det(A) != 0){
W = A
} else   if (rank == 1){
idxRow = idxCol = 1
W = A[idxRow,idxCol,drop=FALSE]
} else {
# make matrix square
outerBreak = FALSE
for (i in 1:(nr-rank+1)){
for (j in 1:(nc-rank+1)){
print(i:(i+rank-1))
print(j:(j+rank-1))
print(A[i:(i+rank-1),j:(j+rank-1)])
print(det(A[i:(i+rank-1),j:(j+rank-1)]))
if (det(A[i:(i+rank-1),j:(j+rank-1)]) != 0){
idxRow = c(i:(i+rank-1))
idxCol = c(j:(j+rank-1))
outerBreak = TRUE
break
}
if(outerBreak){
break
}
}
}
if (!outerBreak){
message("All submatrices are singular! Generalized Inverse could not be calculated!")
return(NULL)
}
W <- A[idxRow, idxCol]
}
# check assumptions for non-singularity
if (det(W) == 0){
message("Hope that never happens ;)")
return(NULL)
}
### step 2 : (W^-1)^T
message("Step 2 : (W^-1)^T!")
# create adjoint matrix - adjoint() doesnt work for 2x2
if (dim(W)[1] == 2){
adj_W = -1*W
diag(adj_W) = rev(diag(W))
} else {
adj_W = adjugate(W)
}
transp_inv_W <- t(adj_W/det(W))
### step 3 : replace elements of A with (W^-1)^T
message("Step 3 : Project rows/cols of (W^-1)^T into a a zero matrix A0 of order dim(A)!")
# Again, if A is non-singular from scratch skip Step 3
if (nc == nr && det(A) != 0){
A0 = transp_inv_W
} else{
A0 <- 0*A
A0[idxRow,idxCol] = transp_inv_W
}
### step 4 : t(A)
message("Step 3 : G = A0^T!")
G <- t(A0)
return(G)
}
A%*%MASS::ginv(A)%*%A
A%*%generalized_Inverse(A)%*%A
det(matrix(1))
generalized_Inverse <- function(A){
### step 1 : Find a LIN submatrix of order rxr
message("Step 1 : Find a LIN submatrix W of order rxr in A!")
nc = ncol(A)
nr = nrow(A)
rank = rank_Matrix(A)
# Check whether A is full rank anyways
if (nc == nr && det(A) != 0){
W = A
} else   if (rank == 1){
idxRow = idxCol = 1
W = A[idxRow,idxCol,drop=FALSE]
} else {
# make matrix square
outerBreak = FALSE
for (i in 1:(nr-rank+1)){
for (j in 1:(nc-rank+1)){
print(i:(i+rank-1))
print(j:(j+rank-1))
print(A[i:(i+rank-1),j:(j+rank-1)])
print(det(A[i:(i+rank-1),j:(j+rank-1)]))
if (det(A[i:(i+rank-1),j:(j+rank-1)]) != 0){
idxRow = c(i:(i+rank-1))
idxCol = c(j:(j+rank-1))
outerBreak = TRUE
break
}
if(outerBreak){
break
}
}
}
if (!outerBreak){
message("All submatrices are singular! Generalized Inverse could not be calculated!")
return(NULL)
}
W <- A[idxRow, idxCol]
}
# # check assumptions for non-singularity
# if (det(W) == 0){
#   message("Hope that never happens ;)")
#   return(NULL)
# }
### step 2 : (W^-1)^T
message("Step 2 : (W^-1)^T!")
# create adjoint matrix - adjoint() doesnt work for 2x2
if (dim(W)[1] == 2){
adj_W = -1*W
diag(adj_W) = rev(diag(W))
} else {
adj_W = adjugate(W)
}
transp_inv_W <- t(adj_W/det(W))
### step 3 : replace elements of A with (W^-1)^T
message("Step 3 : Project rows/cols of (W^-1)^T into a a zero matrix A0 of order dim(A)!")
# Again, if A is non-singular from scratch skip Step 3
if (nc == nr && det(A) != 0){
A0 = transp_inv_W
} else{
A0 <- 0*A
A0[idxRow,idxCol] = transp_inv_W
}
### step 4 : t(A)
message("Step 3 : G = A0^T!")
G <- t(A0)
return(G)
}
A%*%MASS::ginv(A)%*%A
A%*%generalized_Inverse(A)%*%A
from?
?from
?from
inverse <- function(A){
# Check for squareness
if (nrow(A) != ncol(A)){
message("Matrix is not invertible")
return(NULL)
}
# check for singularity
if (det(A) == 0){
message("Matrix is not invertible")
return(NULL)
}
# invert!
adjA = adjugate(A)
return(adjA*det(A)^-1)
}
create_Basis(3)
create_Basis <- function(dim, lower = 0, upper = 9){
basis = matrix(sample(lower:upper,dim^2), nrow = dim)
while (det(basis) == 0){
basis = matrix(sample(lower:upper,dim^2), nrow = dim)
}
if (returnMat){
return(basis) # return in matrix form
}
# output list of vecs instead of matrix
out = list()
for (rowcol in 1:dim){
out[[rowcol]] = basis[,rowcol]
}
return(out)
}
inverse <- function(A){
# Check for squareness
if (nrow(A) != ncol(A)){
message("Matrix is not invertible")
return(NULL)
}
# check for singularity
if (det(A) == 0){
message("Matrix is not invertible")
return(NULL)
}
# invert!
adjA = adjugate(A)
return(adjA*det(A)^-1)
}
create_Basis(3)
create_Basis <- function(dim, lower = 0, upper = 9, returnMat = F){
basis = matrix(sample(lower:upper,dim^2), nrow = dim)
while (det(basis) == 0){
basis = matrix(sample(lower:upper,dim^2), nrow = dim)
}
if (returnMat){
return(basis) # return in matrix form
}
# output list of vecs instead of matrix
out = list()
for (rowcol in 1:dim){
out[[rowcol]] = basis[,rowcol]
}
return(out)
}
inverse <- function(A){
# Check for squareness
if (nrow(A) != ncol(A)){
message("Matrix is not invertible")
return(NULL)
}
# check for singularity
if (det(A) == 0){
message("Matrix is not invertible")
return(NULL)
}
# invert!
adjA = adjugate(A)
return(adjA*det(A)^-1)
}
inverse(create_Basis(3))
create_Basis(3)
inverse(create_Basis(3, returnMat = T))
A = create_Basis(3, returnMat = T)
A = create_Basis(3, returnMat = T)
A%*%inverse(A) == A
round(A%*%inverse(A)) == A
A
A%*%inverse(A)
round(A%*%inverse(A))
A = create_Basis(3, returnMat = T)
round(A%*%inverse(A))
A = create_Basis(3, returnMat = T)
round(A%*%inverse(A))
A = create_Basis(3, returnMat = T)
round(A%*%inverse(A))
A = create_Basis(3, returnMat = T)
round(A%*%inverse(A))
A = create_Basis(3, returnMat = T)
round(A%*%inverse(A))
A = create_Basis(3, returnMat = T)
round(A%*%inverse(A))
A = create_Basis(3, returnMat = T)
round(A%*%inverse(A))
A = create_Basis(3, returnMat = T)
round(A%*%inverse(A))
A = create_Basis(3, returnMat = T)
A = create_Basis(3, returnMat = T)
create_Basis(3, returnMat = T)
create_Basis(3, returnMat = T)
create_Basis(3, returnMat = T)
create_Basis(3, returnMat = T)
create_Basis(3, returnMat = T)
create_Basis(3, returnMat = T)
create_Basis(3, returnMat = T)
create_Basis(3, returnMat = T)
create_Basis(3, returnMat = T)
create_Basis(3, returnMat = T)
create_Basis(3, returnMat = T)
create_Basis(3, returnMat = T)
create_Basis(3, returnMat = T)
create_Basis(3, returnMat = T)
create_Basis(3, returnMat = T)
create_Basis(3, returnMat = T)
create_Basis(3, returnMat = T)
create_Basis(3, returnMat = T)
create_Basis(3, returnMat = T)
A = create_Basis(10, returnMat = T)
create_Basis(9, returnMat = T)
create_Basis <- function(dim, lower = 0, upper = 9, returnMat = F){
basis = matrix(sample(lower:upper,dim^2,replace =T), nrow = dim)
while (det(basis) == 0){
basis = matrix(sample(lower:upper,dim^2,replace =T), nrow = dim)
}
if (returnMat){
return(basis) # return in matrix form
}
# output list of vecs instead of matrix
out = list()
for (rowcol in 1:dim){
out[[rowcol]] = basis[,rowcol]
}
return(out)
}
inverse <- function(A){
# Check for squareness
if (nrow(A) != ncol(A)){
message("Matrix is not invertible")
return(NULL)
}
# check for singularity
if (det(A) == 0){
message("Matrix is not invertible")
return(NULL)
}
# invert!
adjA = adjugate(A)
return(adjA*det(A)^-1)
}
A = create_Basis(9, returnMat = T)
create_Basis(9, returnMat = T)
det(create_Basis(9, returnMat = T))
det(create_Basis(9, returnMat = T))
det(create_Basis(9, returnMat = T))
det(create_Basis(9, returnMat = T))
det(create_Basis(9, returnMat = T))
det(create_Basis(9, returnMat = T))
det(create_Basis(9, returnMat = T))
det(create_Basis(9, returnMat = T))
det(create_Basis(9, returnMat = T))
det(create_Basis(9, returnMat = T))
det(create_Basis(9, returnMat = T))
det(create_Basis(9, returnMat = T))
det(create_Basis(9, returnMat = T))
det(create_Basis(9, returnMat = T))
round(A%*%inverse(A))
orthogonalize <- function(A){
preQ = A%*%t(A)
Q = eigen(preQ, symmetric = T)$vectors
for (row in 1:nrow(Q)){
# Normalize Rows
Q[row,] = 1/sqrt(c(Q[row,]%*%Q[row,]))*c(Q[row,])
}
return(Q)
}
orthogonalize(A)
orthogonalize(A)%*%A
A%*%orthogonalize(A)
orthogonalize(A)%*%orthogonalize(t(A))
orthogonalize(A)%*%orthogonalize(t(A))
orthogonalize(A)%*%orthogonalize(t(A))
orthogonalize(A)%*%orthogonalize(t(A))
orthogonalize(A)%*%orthogonalize(t(A))
orthogonalize(A)%*%orthogonalize(t(A))
generalized_Inverse <- function(A){
### step 1 : Find a LIN submatrix of order rxr
message("Step 1 : Find a LIN submatrix W of order rxr in A!")
nc = ncol(A)
nr = nrow(A)
rank = rank_Matrix(A)
# Check whether A is full rank anyways
if (nc == nr && det(A) != 0){
W = A
} else   if (rank == 1){
idxRow = idxCol = 1
W = A[idxRow,idxCol,drop=FALSE]
} else {
# make matrix square
outerBreak = FALSE
for (i in 1:(nr-rank+1)){
for (j in 1:(nc-rank+1)){
print(i:(i+rank-1))
print(j:(j+rank-1))
print(A[i:(i+rank-1),j:(j+rank-1)])
print(det(A[i:(i+rank-1),j:(j+rank-1)]))
if (det(A[i:(i+rank-1),j:(j+rank-1)]) != 0){
idxRow = c(i:(i+rank-1))
idxCol = c(j:(j+rank-1))
outerBreak = TRUE
break
}
if(outerBreak){
break
}
}
}
if (!outerBreak){
message("All submatrices are singular! Generalized Inverse could not be calculated!")
return(NULL)
}
W <- A[idxRow, idxCol]
}
### step 2 : (W^-1)^T
message("Step 2 : (W^-1)^T!")
# create adjoint matrix - adjoint() doesnt work for 2x2
if (dim(W)[1] == 2){
adj_W = -1*W
diag(adj_W) = rev(diag(W))
} else {
adj_W = adjugate(W)
}
transp_inv_W <- t(adj_W/det(W))
### step 3 : replace elements of A with (W^-1)^T
message("Step 3 : Project rows/cols of (W^-1)^T into a a zero matrix A0 of order dim(A)!")
# Again, if A is non-singular from scratch skip Step 3
if (nc == nr && det(A) != 0){
A0 = transp_inv_W
} else{
A0 <- 0*A
A0[idxRow,idxCol] = transp_inv_W
}
### step 4 : t(A)
message("Step 3 : G = A0^T!")
G <- t(A0)
return(G)
}
A <- t(matrix(c(2,3,1,-1,
5,8,0,1,
1,2,-2,3), nrow = 3))
A
A <- t(matrix(c(2,3,1,-1,
5,8,0,1,
1,2,-2,3), nrow = 4))
A
generalized_Inverse(A)
MASS::ginv(A)
A%*%MASS::ginv(A)%*%A
A%*%generalized_Inverse(A)%*%A
generalized_Inverse(A)
A%*%generalized_Inverse(A)%*%A
A%*%MASS::ginv(A)%*%A
A%*%MASS::ginv(A)
MASS::ginv(A)%*%A
I = diag(3)
J = matrix(1,nrow = 3, ncol = 3)
I = diag(3)
J = matrix(1,nrow = 3, ncol = 3)
I = diag(3)
J = matrix(1,nrow = 3, ncol = 3)
J_bar = 1/3*J
J_bar
C = I - J_bar
C
eigen(C)
rank_Matrix(C)
qr(C)$rank
rank_Matrix(C)
qr(C)$rank
rref(C)
ref(C)
rank_Matrix <- function(A){
A = ref(A)
rank = nrow(A[-c(find_Zero_Vectors(A)),,drop=FALSE])
return(rank)
}
rank_Matrix(C)
A = ref(C)
A
nrow(A[-c(find_Zero_Vectors(A)),,drop=FALSE])
find_Zero_Vectors(A)
-c(find_Zero_Vectors(A))
return(rank)
A[-c(find_Zero_Vectors(A)),,drop=FALSE]
rank_Matrix <- function(A){
A = ref(A)
zeroVecsIdx = find_Zero_Vectors(A)
if (length(zeroVecsIdx) == 0){
return(nrow(A))
} else {
return(nrow(A[-zeroVecsIdx,,drop=FALSE]))
}
}
A = ref(C)
rank_Matrix()
C
rank_Matrix(C)
rank_square_Matrix(C)
qr(C)$rank
rref(C)
ref(C)
C
pracma::rref(C)
install.packages(pracma)
install.packages("pracma")
pracma::rref(C)
ref(C)
10*C
round(10*C)
C
C2 = round(10*C)
pracma::rref(C2)
ref(C2)
rref(C2)
C2
linDep_Cautchy_Schwartz_Matrix(C2)
