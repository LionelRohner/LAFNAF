}
}
return(list(A=A,idxPivots=idxPivots))
}
pracma::rref(A)
rref2(A)
A <- rref2(A)
pivots <- A$idxPivots
A <- A$A
# symmetric + pos def
A <- t(matrix(c(2,2,1,
2,5,1,
1,1,2), nrow = 3))
# lin dep 3x3 (Row 1 + Row 2 == Row 3)
A <- t(matrix(c(2,2,2,
-2,2,-2,
0,4,0), nrow = 3))
pracma::rref(A)
A <- rref2(A)
remove_Parallel_Vectors <- function(A){
# find parallel vectors
rmIdx = unique(linDep_Cautchy_Schwartz_Matrix(A)$j)
nc = ncol(A)
# put zero-vector and parallel vectors at the bottom
if (!is.null(rmIdx)){
A[rmIdx,] <- rep(0,nc)
return(add_To_Bottom(A,rmIdx))
} else {
return(A)
}
}
pracma::rref(A)
A <- rref2(A)
remove_Parallel_Vectors <- function(A){
# find parallel vectors
rmIdx = unique(linDep_Cautchy_Schwartz_Matrix(A)$j)
nc = ncol(A)
# put zero-vector and parallel vectors at the bottom
if (!is.null(rmIdx)){
A[rmIdx,] <- rep(0,nc)
return(add_To_Bottom(A,rmIdx))
} else {
return(A)
}
}
remove_Parallel_Vectors <- function(A){
# find parallel vectors
rmIdx = unique(linDep_Cautchy_Schwartz_Matrix(A)$j)
nc = ncol(A)
# put zero-vector and parallel vectors at the bottom
if (!is.null(rmIdx)){
A[rmIdx,] <- rep(0,nc)
return(add_To_Bottom(A,rmIdx))
} else {
return(A)
}
}
rref2 <- function(A){
# Corner Case 1: all zero matrix
if (max(abs(A)) == 0){
return(A)
}
# 1.) Setup variables
nc = ncol(A)
nr = nrow(A)
# first pivot must be on first column
currentCol = 1
idxPivots = data.frame(i = 1, j = 1)
# 1.1.) remove parallel vectors
rmIdx = unique(linDep_Cautchy_Schwartz_Matrix(A)$j)
# 1.2.) set small values to zero
ifelse(abs(A) <= 1e-10, 0, A)
# put zero-vector and parallel vectors at the bottom
if (!is.null(rmIdx)){
A[rmIdx,] <- rep(0,nc)
A <- add_To_Bottom(A,rmIdx)
}
# 2.) find first pivot (if exists, else normalize first row to first element)
firstPivotIdx = which(A[,1]==1)[1]
# check if a pivot exists?
if (!is.na(firstPivotIdx)){
A <- swap(A,firstPivotIdx,1)
} else {
# Create a pivot (normalize first row)
A[1,] = (1/A[1,1]) * A[1,]
}
# 2.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = currentCol)){
# find nonzero elements in col. vector
idxNonzero = which(A[-1,currentCol]!=0) + currentCol
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,currentCol)
}
# 2.2.) Reorganize matrix such that zero vectors are at the bottom, rm parallel vectors
A = swap_Zero_Vectors(A)
A = remove_Parallel_Vectors(A)
# 3.) find potential next pivots and swap rows if exist
currentCol = 2
currentRow = 1
# make loop even easier
for (col in currentCol:nc){
# skip if col is zero
if (all(A[-c(1:currentRow),col] == 0)){
next
}
# go one row down to follow the diagonal if the column is not full of zeros
currentRow = currentRow + 1
# create new pivot
A[currentRow,] = (1/A[currentRow,col]) * A[currentRow,]
# add pivot index
idxPivots = rbind(idxPivots,c(currentRow, col))
# 3.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = col)){
# find nonzero elements in col. vector
idxNonzero = which(A[-c(1:currentRow),col]!=0) + col
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,col)
}
}
# clean output
zeroVecs = find_Zero_Vectors(A)
if (length(zeroVecs) == 0){
A_reduced = A
# number of rows w/o zero vectors
nrTest = nrow(A_reduced)
# if the number of pivots on the diagonal submatrix of sice col x col = max rank
# then the result must be the identity matrix. This is not a very nice work around
# since actually the algo should perform gaussian elemintation of free variables.
if (all(diag(A_reduced) == 1)){
# if matrix has max rank (e.g. mxn where m <= n, then rank = m)
A = diag(nrTest)
return(list(A=A,idxPivots=idxPivots))
}
} else {
A_reduced = A[-zeroVecs,]
# number of rows w/o zero vectors
nrTest = nrow(A_reduced)
# if the number of pivots on the diagonal submatrix of sice col x col = max rank
# then the result must be the identity matrix. This is not a very nice work around
# since actually the algo should perform gaussian elemintation of free variables.
if (all(diag(A_reduced) == 1)){
# if matrix has max rank (e.g. mxn where m <= n, then rank = m)
A = rbind(diag(nrTest),matrix(0,nrow = nr-nrTest, ncol = nc))
return(list(A=A,idxPivots=idxPivots))
}
}
return(list(A=A,idxPivots=idxPivots))
}
pracma::rref(A)
A <- rref2(A)
rref2 <- function(A){
# Corner Case 1: all zero matrix
if (max(abs(A)) == 0){
return(A)
}
# 1.) Setup variables
nc = ncol(A)
nr = nrow(A)
# first pivot must be on first column
currentCol = 1
idxPivots = data.frame(i = 1, j = 1)
# 1.1.) remove parallel vectors
rmIdx = unique(linDep_Cautchy_Schwartz_Matrix(A)$j)
# 1.2.) set small values to zero
ifelse(abs(A) <= 1e-10, 0, A)
# put zero-vector and parallel vectors at the bottom
if (!is.null(rmIdx)){
A[rmIdx,] <- rep(0,nc)
A <- add_To_Bottom(A,rmIdx)
}
# 2.) find first pivot (if exists, else normalize first row to first element)
firstPivotIdx = which(A[,1]==1)[1]
# check if a pivot exists?
if (!is.na(firstPivotIdx)){
A <- swap(A,firstPivotIdx,1)
} else {
# Create a pivot (normalize first row)
A[1,] = (1/A[1,1]) * A[1,]
}
# 2.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = currentCol)){
# find nonzero elements in col. vector
idxNonzero = which(A[-1,currentCol]!=0) + currentCol
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,currentCol)
}
# 2.2.) Reorganize matrix such that zero vectors are at the bottom, rm parallel vectors
A = swap_Zero_Vectors(A)
A = remove_Parallel_Vectors(A)
# 3.) find potential next pivots and swap rows if exist
currentCol = 2
currentRow = 1
# make loop even easier
for (col in currentCol:nc){
# skip if col is zero
if (all(A[-c(1:currentRow),col] == 0)){
next
}
# go one row down to follow the diagonal if the column is not full of zeros
currentRow = currentRow + 1
# create new pivot
A[currentRow,] = (1/A[currentRow,col]) * A[currentRow,]
# add pivot index
idxPivots = rbind(idxPivots,c(currentRow, col))
# 3.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = col)){
# find nonzero elements in col. vector
idxNonzero = which(A[-c(1:currentRow),col]!=0) + col
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,col)
}
}
# clean output
zeroVecs = find_Zero_Vectors(A)
if (length(zeroVecs) == 0){
A_reduced = A
# number of rows w/o zero vectors
nrTest = nrow(A_reduced)
# if the number of pivots on the diagonal submatrix of sice col x col = max rank
# then the result must be the identity matrix. This is not a very nice work around
# since actually the algo should perform gaussian elemintation of free variables.
if (all(diag(A_reduced) == 1)){
# if matrix has max rank (e.g. mxn where m <= n, then rank = m)
A = diag(nrTest)
return(list(A=A,idxPivots=idxPivots))
}
} else {
A_reduced = A[-zeroVecs,]
# number of rows w/o zero vectors
nrTest = nrow(A_reduced)
# if the number of pivots on the diagonal submatrix of sice col x col = max rank
# then the result must be the identity matrix. This is not a very nice work around
# since actually the algo should perform gaussian elemintation of free variables.
if (all(diag(A_reduced) == 1)){
# if matrix has max rank (e.g. mxn where m <= n, then rank = m)
# TESTINGTESTINGTESTINGTESTINGTESTINGTESTINGTESTING
# TESTINGTESTINGTESTINGTESTINGTESTINGTESTINGTESTING
# A = rbind(diag(nrTest),matrix(0,nrow = nr-nrTest, ncol = nc))
return(list(A=A,idxPivots=idxPivots))
}
}
return(list(A=A,idxPivots=idxPivots))
}
pracma::rref(A)
A <- rref2(A)
rref2 <- function(A){
# Corner Case 1: all zero matrix
if (max(abs(A)) == 0){
return(A)
}
# 1.) Setup variables
nc = ncol(A)
nr = nrow(A)
# first pivot must be on first column
currentCol = 1
idxPivots = data.frame(i = 1, j = 1)
# 1.1.) remove parallel vectors
rmIdx = unique(linDep_Cautchy_Schwartz_Matrix(A)$j)
# 1.2.) set small values to zero
ifelse(abs(A) <= 1e-10, 0, A)
# put zero-vector and parallel vectors at the bottom
if (!is.null(rmIdx)){
A[rmIdx,] <- rep(0,nc)
A <- add_To_Bottom(A,rmIdx)
}
# 2.) find first pivot (if exists, else normalize first row to first element)
firstPivotIdx = which(A[,1]==1)[1]
# check if a pivot exists?
if (!is.na(firstPivotIdx)){
A <- swap(A,firstPivotIdx,1)
} else {
# Create a pivot (normalize first row)
A[1,] = (1/A[1,1]) * A[1,]
}
# 2.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = currentCol)){
# find nonzero elements in col. vector
idxNonzero = which(A[-1,currentCol]!=0) + currentCol
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,currentCol)
}
# 2.2.) Reorganize matrix such that zero vectors are at the bottom, rm parallel vectors
A = swap_Zero_Vectors(A)
A = remove_Parallel_Vectors(A)
# 3.) find potential next pivots and swap rows if exist
currentCol = 2
currentRow = 1
# make loop even easier
for (col in currentCol:nc){
# skip if col is zero
if (all(A[-c(1:currentRow),col] == 0)){
next
}
# go one row down to follow the diagonal if the column is not full of zeros
currentRow = currentRow + 1
# create new pivot
A[currentRow,] = (1/A[currentRow,col]) * A[currentRow,]
# add pivot index
idxPivots = rbind(idxPivots,c(currentRow, col))
# 3.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = col)){
# find nonzero elements in col. vector
idxNonzero = which(A[-c(1:currentRow),col]!=0) + col
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,col)
}
}
# clean output
zeroVecs = find_Zero_Vectors(A)
if (length(zeroVecs) == 0){
A_reduced = A
# number of rows w/o zero vectors
nrTest = nrow(A_reduced)
# if the number of pivots on the diagonal submatrix of sice col x col = max rank
# then the result must be the identity matrix. This is not a very nice work around
# since actually the algo should perform gaussian elemintation of free variables.
if (all(diag(A_reduced) == 1)){
# if matrix has max rank (e.g. mxn where m <= n, then rank = m)
A = diag(nrTest)
return(list(A=A,idxPivots=idxPivots))
}
} else {
A_reduced = A[-zeroVecs,]
# number of rows w/o zero vectors
nrTest = nrow(A_reduced)
# if the number of pivots on the diagonal submatrix of sice col x col = max rank
# then the result must be the identity matrix. This is not a very nice work around
# since actually the algo should perform gaussian elemintation of free variables.
if (all(diag(A_reduced) == 1)){
# if matrix has max rank (e.g. mxn where m <= n, then rank = m)
# TESTINGTESTINGTESTINGTESTINGTESTINGTESTINGTESTING
# TESTINGTESTINGTESTINGTESTINGTESTINGTESTINGTESTING
# A = rbind(diag(nrTest),matrix(0,nrow = nr-nrTest, ncol = nc))
return(list(A=A,idxPivots=idxPivots))
}
}
return(list(A=A,idxPivots=idxPivots))
}
pracma::rref(A)
A <- rref2(A)
A
pivots[2,]
for (pivot in 2:nrow(pivots)){
print(pivot)
}
pivots <- A$idxPivots
pivots
for (pivot in 2:nrow(pivots)){
print(pivot)
}
pivots[2,]
A[-c(1:pivot),pivot]
A
A <- A$A
A[-c(1:pivot),pivot]
A
-c(1:pivot)
A
A[-c(1:pivot-1),pivot]
pivot
A[-c(pivot:ncol(A)),pivot]
rep(0,1:pivot)
1:pivot
A[-c(pivot:ncol(A)),pivot] = rep(0,pivot-1)
A
# full rank 5x5
A <- t(matrix(c(1,2,3, 4,-2,
-1,0,1,4,-7,
7,1,-2,4,1,
1,0,10,2,0,
213,1,8,6,4), nrow = 5))
pracma::rref(A)
A <- rref2(A)
A
for (pivot in 2:nrow(pivots)){
A[-c(pivot:ncol(A)),pivot] = rep(0,pivot-1)
}
A[-c(pivot:ncol(A)),pivot] = rep(0,pivot-1)
# clear rref!!
pracma::rref(A)
A
A <- A$A
# clear rref!!
pracma::rref(A)
A <- rref2(A)
A
A
# full rank 5x5
A <- t(matrix(c(1,2,3, 4,-2,
-1,0,1,4,-7,
7,1,-2,4,1,
1,0,10,2,0,
213,1,8,6,4), nrow = 5))
# clear rref!!
pracma::rref(A)
A <- rref2(A)
A
pivots <- A$idxPivots
A <- A$A
A[-c(pivot:ncol(A)),pivot] = rep(0,pivot-1)
A
# full rank 5x5
A <- t(matrix(c(1,2,3, 4,-2,
-1,0,1,4,-7,
7,1,-2,4,1,
1,0,10,2,0,
213,1,8,6,4), nrow = 5))
# clear rref!!
pracma::rref(A)
A <- rref2(A)
pivots <- A$idxPivots
A <- A$A
for (pivot in 2:nrow(pivots)){
A[-c(pivot:ncol(A)),pivot] = rep(0,pivot-1)
}
A
# remove free variables above pivots
for (pivot in 2:nrow(pivots)){
A[-c(pivot:ncol(A)),pivot] = rep(0,pivot-1)
}
# full rank - all positive entries
A <- t(matrix(c(2,0,2,
3,4,5,
17,13,0), nrow = 3))
# clear rref!!
pracma::rref(A)
A <- rref2(A)
pivots <- A$idxPivots
A <- A$A
# remove free variables above pivots
for (pivot in 2:nrow(pivots)){
A[-c(pivot:ncol(A)),pivot] = rep(0,pivot-1)
}
A
A$A
A <- rref2(A)
pivots <- A$idxPivots
A <- A$A
A
# clear rref!!
pracma::rref(A)
A <- rref2(A)
A
# lin dep rect
A <- t(matrix(c(1,2,3,4,
1,2,3,4,
1,2,3,4,
1,2,3,4,
-1,0,1,-3,
7,1,-2,-3,
1,2,3,4,
1,2,3,4,
1,2,3,4,
1,2,3,4), nrow = 4))
# clear rref!!
pracma::rref(A)
A <- rref2(A)
pivots <- A$idxPivots
A <- A$A
A
# remove free variables above pivots
for (pivot in pivots){
print(pivots)
}
# remove free variables above pivots
for (pivot in pivots){
print(pivots)
}
pivots
pivots
pivot = 2
A[pivot+1,]-A[pivots[pivot,pivot],pivot]*A[pivot,]
A
rev(2:nrow(pivots))
# remove free variables above pivots
for (pivot in rev(2:nrow(pivots))){
A[pivot+1,] = A[pivot+1,]-A[pivots[pivot,pivot],pivot]*A[pivot,]
}
# remove free variables above pivots
for (pivot in 2:nrow(pivots)){
A[pivot+1,] = A[pivot+1,]-A[pivots[pivot,pivot],pivot]*A[pivot,]
}
A[pivot+1,]
pivot = 2
A[pivot+1,]-A[pivots[pivot,pivot],pivot]*A[pivot,]
A[pivot+1,]-A[pivot,]
pivot = 2
A[pivot-1,]-A[pivot,]*A[pivots[pivot,pivot],pivot]
A
A <- A$A
A
A <- rref2(A)
pivots <- A$idxPivots
A <- A$A
A
# remove free variables above pivots
for (pivot in 2:nrow(pivots)){
A[pivot-1,] = A[pivot-1,]-A[pivots[pivot,pivot],pivot]*A[pivot,]
}
rows = pivots$i
cols = pivots$j
col = 2
row = 1
col = 2
A[row-1,col]  == pivots[row,col]
A[row-1,col]
A
A[row+1,col]
c(row+1,col)
pivots[row,col]
pivots[row+1,]
c(row+1,col)  == pivots[row+1,]
