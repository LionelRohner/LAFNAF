# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,col)
}
}
A
A = C
# Corner Case 1: all zero matrix
if (max(abs(A)) == 0){
return(A)
}
# 1.) Setup variables
nc = ncol(A)
nr = nrow(A)
# first pivot must be on first column
currentCol = 1
idxPivots = data.frame(i = 1, j = 1)
# 1.1.) remove parallel vectors
rmIdx = unique(linDep_Cautchy_Schwartz_Matrix(A)$j)
# 1.2.) set small values to zero
A = ifelse(abs(A) <= 1e-10, 0, A)
# put zero-vector and parallel vectors at the bottom
if (!is.null(rmIdx)){
A[rmIdx,] <- rep(0,nc)
A <- add_To_Bottom(A,rmIdx)
}
A
# 2.) find first pivot (if exists, else normalize first row to first element)
firstPivotIdx = which(A[,1]==1)[1]
# check if a pivot exists?
if (!is.na(firstPivotIdx)){
A <- swap(A,firstPivotIdx,1)
} else {
# Create a pivot (normalize first row)
A[1,] = (1/A[1,1]) * A[1,]
}
# 2.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = currentCol)){
# find nonzero elements in col. vector
idxNonzero = which(A[-1,currentCol]!=0) + currentCol
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,currentCol)
}
# 2.2.) Reorganize matrix such that zero vectors are at the bottom, rm parallel vectors
A = swap_Zero_Vectors(A)
A = remove_Parallel_Vectors(A)
A2 = A
# 3.) find potential next pivots and swap rows if exist
currentCol = 2
currentRow = 1
# skip if col is zero
if (all(A[-c(1:currentRow),col] == 0)){
next
}
A
# go one row down to follow the diagonal if the column is not full of zeros
currentRow = currentRow + 1
# create new pivot
A[currentRow,] = (1/A[currentRow,col]) * A[currentRow,]
A
(1/A[currentRow,col]) * A[currentRow,]
(1/A[currentRow,col]) * A[currentRow,]
# full rank 3x3
A <- t(matrix(c(1,2,3,
-1,0,1,
7,1,-2), nrow = 3))
-1*A
A = -1*A
ref(A)
rref(A)
pracma::rref(A)
A = -1*A
ref(A)
pracma::rref(A)
ref(A)
ref(A)
ref(A)
ref(A)
ref(A)
ref(A)
ref(A)
ref(A)
ref(A)
ref(A)
A
A = A2
# 3.) find potential next pivots and swap rows if exist
currentCol = 2
currentRow = 1
# skip if col is zero
if (all(A[-c(1:currentRow),col] == 0)){
next
}
A
# go one row down to follow the diagonal if the column is not full of zeros
currentRow = currentRow + 1
# create new pivot
A[currentRow,] = (1/A[currentRow,col]) * A[currentRow,]
A
A = A2
A[currentRow,]
A[currentRow,col])
A[currentRow,col]
1/A[currentRow,col]
1/A[currentRow,col]
A[currentRow,col]
# add pivot index
idxPivots = rbind(idxPivots,c(currentRow, col))
idxPivots
A = A2
# 3.) find potential next pivots and swap rows if exist
currentCol = 2
currentRow = 1
# skip if col is zero
if (all(A[-c(1:currentRow),col] == 0)){
next
}
A
# go one row down to follow the diagonal if the column is not full of zeros
currentRow = currentRow + 1
# create new pivot
A[currentRow,] = (1/A[currentRow,col]) * A[currentRow,]
# add pivot index
idxPivots = rbind(idxPivots,c(currentRow, col))
idxPivots
A = A2
# 3.) find potential next pivots and swap rows if exist
currentCol = 2
currentRow = 1
# skip if col is zero
if (all(A[-c(1:currentRow),col] == 0)){
next
}
A
# go one row down to follow the diagonal if the column is not full of zeros
currentRow = currentRow + 1
currentRow
# create new pivot
A[currentRow,] = (1/A[currentRow,col]) * A[currentRow,]
# add pivot index
idxPivots = rbind(idxPivots,c(currentRow, col))
idxPivots
create_Basis <- function(dim, negative = T, upper = 9, returnMat = F){
if (negative){
lower = -upper
} else {
lower = 0
}
basis = matrix(sample(lower:upper,dim^2,replace =T), nrow = dim)
while (det(basis) == 0){
basis = matrix(sample(lower:upper,dim^2,replace =T), nrow = dim)
}
if (returnMat){
return(basis) # return in matrix form
}
# output list of vecs instead of matrix
out = list()
for (rowcol in 1:dim){
out[[rowcol]] = basis[,rowcol]
}
return(out)
}
create_Basis(3)
create_Basis(3, returnMat = T)
rref(create_Basis(3, returnMat = T))
rref(create_Basis(3, returnMat = T))
rref(create_Basis(3, returnMat = T))
rref(create_Basis(3, returnMat = T))
rref(create_Basis(3, returnMat = T))
rref(create_Basis(3, returnMat = T))
rref(create_Basis(3, returnMat = T))
rref(create_Basis(3, returnMat = T))
rref(create_Basis(3, returnMat = T))
rref(create_Basis(3, returnMat = T))
rref(create_Basis(3, returnMat = T))
rref(create_Basis(3, returnMat = T))
rref(create_Basis(3, returnMat = T))
rref(create_Basis(3, returnMat = T))
rref(create_Basis(3, returnMat = T))
rref(create_Basis(3, returnMat = T))
rref(create_Basis(3, returnMat = T))
rref(create_Basis(3, returnMat = T))
rref(create_Basis(3, returnMat = T))
rref(create_Basis(3, returnMat = T))
rref(create_Basis(3, returnMat = T))
rref(create_Basis(3, returnMat = T))
rref(create_Basis(3, returnMat = T))
rref(create_Basis(3, returnMat = T))
rref(create_Basis(3, returnMat = T))
rref(create_Basis(3, returnMat = T))
check_sign <- function(scalar){
if (scalar > 0){
return(scalar)
} else {
return(-1*scalar)
}
}
flip_sign <- function(scalar){
if (scalar > 0){
return(scalar)
} else {
return(-1*scalar)
}
}
ref <- function(A){
# Corner Case 1: all zero matrix
if (max(abs(A)) == 0){
return(A)
}
# 1.) Setup variables
nc = ncol(A)
nr = nrow(A)
# first pivot must be on first column
currentCol = 1
idxPivots = data.frame(i = 1, j = 1)
# 1.1.) remove parallel vectors
rmIdx = unique(linDep_Cautchy_Schwartz_Matrix(A)$j)
# 1.2.) set small values to zero
A = ifelse(abs(A) <= 1e-10, 0, A)
# put zero-vector and parallel vectors at the bottom
if (!is.null(rmIdx)){
A[rmIdx,] <- rep(0,nc)
A <- add_To_Bottom(A,rmIdx)
}
# 2.) find first pivot (if exists, else normalize first row to first element)
firstPivotIdx = which(A[,1]==1)[1]
# check if a pivot exists?
if (!is.na(firstPivotIdx)){
A <- swap(A,firstPivotIdx,1)
} else {
# Create a pivot (normalize first row)
A[1,] = (1/A[1,1]) * A[1,]
}
# 2.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = currentCol)){
# find nonzero elements in col. vector
idxNonzero = which(A[-1,currentCol]!=0) + currentCol
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,currentCol)
}
# 2.2.) Reorganize matrix such that zero vectors are at the bottom, rm parallel vectors
A = swap_Zero_Vectors(A)
A = remove_Parallel_Vectors(A)
# 3.) find potential next pivots and swap rows if exist
currentCol = 2
currentRow = 1
# make loop even easier
for (col in currentCol:nc){
# skip if col is zero
if (all(A[-c(1:currentRow),col] == 0)){
next
}
# go one row down to follow the diagonal if the column is not full of zeros
currentRow = currentRow + 1
# create new pivot
A[currentRow,] = (1/flip_sign(A[currentRow,col])) * A[currentRow,]
# add pivot index
idxPivots = rbind(idxPivots,c(currentRow, col))
# 3.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = col)){
# find nonzero elements in col. vector
idxNonzero = which(A[-c(1:currentRow),col]!=0) + col
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,col)
}
}
return(A)
}
C
ref(C)
A = A2
# 3.) find potential next pivots and swap rows if exist
currentCol = 2
currentRow = 1
col = currentCol
# skip if col is zero
if (all(A[-c(1:currentRow),col] == 0)){
next
}
A
# go one row down to follow the diagonal if the column is not full of zeros
currentRow = currentRow + 1
# create new pivot
A[currentRow,] = (1/flip_sign(A[currentRow,col])) * A[currentRow,]
A
A = A2
# 3.) find potential next pivots and swap rows if exist
currentCol = 2
currentRow = 1
col = currentCol
# skip if col is zero
if (all(A[-c(1:currentRow),col] == 0)){
next
}
A
# go one row down to follow the diagonal if the column is not full of zeros
currentRow = currentRow + 1
# create new pivot
A[currentRow,] = 1/A[currentRow,col]) * A[currentRow,]
A = A2
# 3.) find potential next pivots and swap rows if exist
currentCol = 2
currentRow = 1
col = currentCol
# skip if col is zero
if (all(A[-c(1:currentRow),col] == 0)){
next
}
A
# go one row down to follow the diagonal if the column is not full of zeros
currentRow = currentRow + 1
# create new pivot
A[currentRow,] = (1/A[currentRow,col]) * A[currentRow,]
A
linDep_Cautchy_Schwartz(A[2,],A[3,])
ref <- function(A){
# Corner Case 1: all zero matrix
if (max(abs(A)) == 0){
return(A)
}
# 1.) Setup variables
nc = ncol(A)
nr = nrow(A)
# first pivot must be on first column
currentCol = 1
idxPivots = data.frame(i = 1, j = 1)
# 1.1.) remove parallel vectors
rmIdx = unique(linDep_Cautchy_Schwartz_Matrix(A)$j)
# 1.2.) set small values to zero
A = ifelse(abs(A) <= 1e-10, 0, A)
# put zero-vector and parallel vectors at the bottom
if (!is.null(rmIdx)){
A[rmIdx,] <- rep(0,nc)
A <- add_To_Bottom(A,rmIdx)
}
# 2.) find first pivot (if exists, else normalize first row to first element)
firstPivotIdx = which(A[,1]==1)[1]
# check if a pivot exists?
if (!is.na(firstPivotIdx)){
A <- swap(A,firstPivotIdx,1)
} else {
# Create a pivot (normalize first row)
A[1,] = (1/A[1,1]) * A[1,]
}
# 2.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = currentCol)){
# find nonzero elements in col. vector
idxNonzero = which(A[-1,currentCol]!=0) + currentCol
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,currentCol)
}
# 3.) find potential next pivots and swap rows if exist
currentCol = 2
currentRow = 1
# make loop even easier
for (col in currentCol:nc){
# 3.2.) Reorganize matrix such that zero vectors are at the bottom, rm parallel vectors
A = swap_Zero_Vectors(A)
A = remove_Parallel_Vectors(A)
# skip if col is zero
if (all(A[-c(1:currentRow),col] == 0)){
next
}
# go one row down to follow the diagonal if the column is not full of zeros
currentRow = currentRow + 1
# create new pivot
A[currentRow,] = (1/A[currentRow,col]) * A[currentRow,]
# add pivot index
idxPivots = rbind(idxPivots,c(currentRow, col))
# 3.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = col)){
# find nonzero elements in col. vector
idxNonzero = which(A[-c(1:currentRow),col]!=0) + col
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,col)
}
}
return(A)
}
ref(C)
rref <- function(A){
# Corner Case 1: all zero matrix
if (max(abs(A)) == 0){
return(A)
}
# 1.) Setup variables
nc = ncol(A)
nr = nrow(A)
# first pivot must be on first column
currentCol = 1
idxPivots = data.frame(i = 1, j = 1)
# 1.1.) remove parallel vectors
rmIdx = unique(linDep_Cautchy_Schwartz_Matrix(A)$j)
# # 1.2.) set small values to zero
# ifelse(abs(A) <= 1e-10, 0, A)
# put zero-vector and parallel vectors at the bottom
if (!is.null(rmIdx)){
A[rmIdx,] <- rep(0,nc)
A <- add_To_Bottom(A,rmIdx)
}
# 2.) find first pivot (if exists, else normalize first row to first element)
firstPivotIdx = which(A[,1]==1)[1]
# check if a pivot exists?
if (!is.na(firstPivotIdx)){
A <- swap(A,firstPivotIdx,1)
} else {
# Create a pivot (normalize first row)
A[1,] = (1/A[1,1]) * A[1,]
}
# 2.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = currentCol)){
# find nonzero elements in col. vector
idxNonzero = which(A[-1,currentCol]!=0) + currentCol
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,currentCol)
}
# 3.) find potential next pivots and swap rows if exist
currentCol = 2
currentRow = 1
# make loop even easier
for (col in currentCol:nc){
# 3.2.) Reorganize matrix such that zero vectors are at the bottom, rm parallel vectors
A = swap_Zero_Vectors(A)
A = remove_Parallel_Vectors(A)
# skip if col is zero
if (all(A[-c(1:currentRow),col] == 0)){
next
}
# go one row down to follow the diagonal if the column is not full of zeros
currentRow = currentRow + 1
# create new pivot
A[currentRow,] = (1/A[currentRow,col]) * A[currentRow,]
# add pivot index
idxPivots = rbind(idxPivots,c(currentRow, col))
# 3.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = col)){
# find nonzero elements in col. vector
idxNonzero = which(A[-c(1:currentRow),col]!=0) + col
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,col)
}
}
# 4.) Now remove all free variable above a pivot
# create matrix containing only the pivots
pivotsVec <- A[idxPivots$i,,drop = FALSE]
#
nr = nrow(pivotsVec)
# this loop starts with the "lowest" pivot vector (piv) (the one with rightmost pivot)
# and subtracts itself from the next pivot (revPiv) vector such that the free variable
# above the current pivot vector (piv).
for (piv in nr:1){
message("piv: ", piv)
for (revPiv in piv:1){
message("revPiv: ", revPiv)
if(piv == revPiv){
next
}
A[revPiv,] = A[revPiv,]-A[piv,]*A[revPiv,piv]
}
}
# 5.) set small values to zero
A = ifelse(abs(A) <= 1e-10, 0, A)
return(A)
}
pracma::rref(C)
rref(C2)
rref(C)
pracma::rref(C)
rref(C)
t = c(-1,0,3)
x = c(2,-2,11)
# full rank - all positive entries
A <- t(matrix(c(2,0,2,
3,4,5,
17,13,0), nrow = 3))
t = c(-1,0,3)
x = c(2,-2,11)
t%*%A%*%x
t(t)%*%A%*%x
t(t%*%t(A))%*%x
t(A)%*%t%*%x
t(t)%*%A%*%x
t(t)%*%A
t(t(t)%*%A)
t(t(t)%*%A)%*%x
t(t(t)%*%A)%*%t(x)
t(t(t)%*%A)
x
t(t(t)%*%A)*x
t*x
t%*%x
t
x
t(t(t)%*%A)%*%x
t(t(t)%*%A)
t(t)%*%A%*%x
t(t(t)%*%A)
-1.3333*3
-4 * -3 * (1/4)
(1/3)*3/4
(1.333)*3/4
(1.333333333333)*3/4
A <- t(matrix(c(1,1,2,1,
3,1,4,4,
4,-4,0,8), nrow = 3))
ref(A)
A
A <- t(matrix(c(1,1,2,1,
3,1,4,4,
4,-4,0,8), nrow = 4))
A
ref(A)
rref(A)
