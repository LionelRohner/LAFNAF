# second plot with transformation
# find new boundaries
v_trans = A%*%v
if (max(v_trans) > maxMat){
maxMat = max(v_trans) + offset
}
if (splitPlot){
# emtpy plot
plot(1, type = "n",
xlab = "", ylab = "",
xlim = c(-maxMat, maxMat), ylim = c(-maxMat, maxMat),
main = "After Transformation", cex.main = 0.75)
# formula for getting angle between vectors
angle <- function(v1,v2){
acos( sum(v1*v2) / ( sqrt(sum(v1*v1)) * sqrt(sum(v2*v2)) ) )
}
# find angle
angle1 = angle(c(1,0),A[,1])
angle2 = -angle(c(0,1),A[,2])
# apply grid (swipe through grid in intervals (seq) and draw abline with slope = angle)
sapply(seq(-maxMat*10,maxMat*10,by=1), function(inter) abline(a=inter,
b=tan(angle1),
lty=3,
col="lightgray"))
sapply(seq(-maxMat*10,maxMat*10,by=4), function(inter) abline(a=inter,
b=tan(angle2+pi/2),
lty=3,
col="lightgray"))
}
# transformed basis vectors
if (plotBasisVecs){
arrows(0,0,A[1,1],A[2,1], length = 0.05, col = rgb(0,0,0.8,0.7))
arrows(0,0,A[1,2],A[2,2], length = 0.05, col = rgb(0,0,0.8,0.7))
}
# span transformed basis vectors
arrows(-A[1,1]*maxMat,-A[2,1]*maxMat,
A[1,1]*maxMat,A[2,1]*maxMat,
length = 0.05, col = rgb(0,0,0.8,0.3), code = 0, lty = 2)
arrows(-A[1,2]*maxMat,-A[2,2]*maxMat,
A[1,2]*maxMat,A[2,2]*maxMat,
length = 0.05, col = rgb(0,0,0.8,0.3), code = 0, lty = 2)
# input vector transformed
arrows(0,0,v_trans[1],v_trans[2], length = 0.05, col = rgb(0.5,0,0.8,0.8))
text(v_trans[1]+1,v_trans[2],paste("[",v_trans[1],v_trans[2],"]"),
col = rgb(0.5,0,0.8,0.8))
# legend
legend("bottomright", c("Basis","Vector y (Ax=y)"),
col = c(rgb(0,0,0.8,0.7),rgb(0.8,0,0.8,0.7)),
pch = c(16,16), inset=c(0,1), xpd=TRUE, horiz=T, bty="n",
cex = 0.75)
# restore par settings to default
par(mfrow = c(1,1))
}
plotMatrixTransformation(A,c(1,3),offset = 2)
plotMatrixTransformation <- function(A,v,
offset = 1,
plotBasisVecs = T,
splitPlot = T){
# assumptions for function:
if (all(dim(A) != 2)){
message("A is not 2x2. Exiting...")
return(NULL)
}
par(mfrow = c(1,2),pty="s")
maxMat = max(A) + offset
plot(1, type = "n",
xlab = "", ylab = "",
xlim = c(-maxMat, maxMat), ylim = c(-maxMat, maxMat),
main = "Before Transformation", cex.main = 0.75)
grid()
# basis vectors
if (plotBasisVecs){
arrows(0,0,0,1, length = 0.05)
arrows(0,0,1,0, length = 0.05)
}
# span basis vectors
arrows(0,-1*2*maxMat,0,1*2*maxMat,
length = 0.05, col = rgb(0,0,0,0.3), code = 0, lty = 2)
arrows(-1*2*maxMat,0,1*2*maxMat,0,
length = 0.05, col = rgb(0,0,0,0.3), code = 0, lty = 2)
# input vector
arrows(0,0,v[1],v[2], length = 0.05, col = rgb(0.8,0,0,0.8))
# plot origin and tip of vec
points(0,0, pch = 16, cex = 0.7,)
points(0,0, pch = 16, cex = 0.7,)
# legend
legend("bottomright", c("Basis","Vector x (Ax=y)"),
col = c(rgb(0,0,0.8,0.7),rgb(0.8,0,0.8,0.7)),
pch = c(16,16), inset=c(0,1), xpd=TRUE, horiz=T, bty="n",
cex = 0.75)
# second plot with transformation
# find new boundaries
v_trans = A%*%v
if (max(v_trans) > maxMat){
maxMat = max(v_trans) + offset
}
if (splitPlot){
# emtpy plot
plot(1, type = "n",
xlab = "", ylab = "",
xlim = c(-maxMat, maxMat), ylim = c(-maxMat, maxMat),
main = "After Transformation", cex.main = 0.75)
# formula for getting angle between vectors
angle <- function(v1,v2){
acos( sum(v1*v2) / ( sqrt(sum(v1*v1)) * sqrt(sum(v2*v2)) ) )
}
# find angle
angle1 = angle(c(1,0),A[,1])
angle2 = -angle(c(0,1),A[,2])
# apply grid (swipe through grid in intervals (seq) and draw abline with slope = angle)
sapply(seq(-maxMat*10,maxMat*10,by=1), function(inter) abline(a=inter,
b=tan(angle1),
lty=3,
col="lightgray"))
sapply(seq(-maxMat*10,maxMat*10,by=4), function(inter) abline(a=inter,
b=tan(angle2+pi/2),
lty=3,
col="lightgray"))
}
# transformed basis vectors
if (plotBasisVecs){
arrows(0,0,A[1,1],A[2,1], length = 0.05, col = rgb(0,0,0.8,0.7))
arrows(0,0,A[1,2],A[2,2], length = 0.05, col = rgb(0,0,0.8,0.7))
}
# span transformed basis vectors
arrows(-A[1,1]*maxMat,-A[2,1]*maxMat,
A[1,1]*maxMat,A[2,1]*maxMat,
length = 0.05, col = rgb(0,0,0.8,0.3), code = 0, lty = 2)
arrows(-A[1,2]*maxMat,-A[2,2]*maxMat,
A[1,2]*maxMat,A[2,2]*maxMat,
length = 0.05, col = rgb(0,0,0.8,0.3), code = 0, lty = 2)
# input vector transformed
arrows(0,0,v_trans[1],v_trans[2], length = 0.05, col = rgb(0.5,0,0.8,0.8))
text(v_trans[1]+offset,v_trans[2],paste("[",v_trans[1],v_trans[2],"]"),
col = rgb(0.5,0,0.8,0.8), cex = 0.75)
# legend
legend("bottomright", c("Basis","Vector y (Ax=y)"),
col = c(rgb(0,0,0.8,0.7),rgb(0.8,0,0.8,0.7)),
pch = c(16,16), inset=c(0,1), xpd=TRUE, horiz=T, bty="n",
cex = 0.75)
# restore par settings to default
par(mfrow = c(1,1))
}
plotMatrixTransformation(A,c(1,3),offset = 2)
plotMatrixTransformation <- function(A,v,
offset = 1,
plotBasisVecs = T,
splitPlot = T){
# assumptions for function:
if (all(dim(A) != 2)){
message("A is not 2x2. Exiting...")
return(NULL)
}
par(mfrow = c(1,2),pty="s")
maxMat = max(A) + offset
plot(1, type = "n",
xlab = "", ylab = "",
xlim = c(-maxMat, maxMat), ylim = c(-maxMat, maxMat),
main = "Before Transformation", cex.main = 0.75)
grid()
# basis vectors
if (plotBasisVecs){
arrows(0,0,0,1, length = 0.05)
arrows(0,0,1,0, length = 0.05)
}
# span basis vectors
arrows(0,-1*2*maxMat,0,1*2*maxMat,
length = 0.05, col = rgb(0,0,0,0.3), code = 0, lty = 2)
arrows(-1*2*maxMat,0,1*2*maxMat,0,
length = 0.05, col = rgb(0,0,0,0.3), code = 0, lty = 2)
# input vector
arrows(0,0,v[1],v[2], length = 0.05, col = rgb(0.8,0,0,0.8))
# plot origin and tip of vec
points(0,0, pch = 16, cex = 0.7,)
points(0,0, pch = 16, cex = 0.7,)
# legend
legend("bottomright", c("Basis","Vector x (Ax=y)"),
col = c(rgb(0,0,0.8,0.7),rgb(0.8,0,0.8,0.7)),
pch = c(16,16), inset=c(0,1), xpd=TRUE, horiz=T, bty="n",
cex = 0.75)
# second plot with transformation
# find new boundaries
v_trans = A%*%v
if (max(v_trans) > maxMat){
maxMat = max(v_trans) + offset
}
if (splitPlot){
# emtpy plot
plot(1, type = "n",
xlab = "", ylab = "",
xlim = c(-maxMat, maxMat), ylim = c(-maxMat, maxMat),
main = "After Transformation", cex.main = 0.75)
# formula for getting angle between vectors
angle <- function(v1,v2){
acos( sum(v1*v2) / ( sqrt(sum(v1*v1)) * sqrt(sum(v2*v2)) ) )
}
# find angle
angle1 = angle(c(1,0),A[,1])
angle2 = -angle(c(0,1),A[,2])
# apply grid (swipe through grid in intervals (seq) and draw abline with slope = angle)
sapply(seq(-maxMat*10,maxMat*10,by=1), function(inter) abline(a=inter,
b=tan(angle1),
lty=3,
col="lightgray"))
sapply(seq(-maxMat*10,maxMat*10,by=4), function(inter) abline(a=inter,
b=tan(angle2+pi/2),
lty=3,
col="lightgray"))
}
# transformed basis vectors
if (plotBasisVecs){
arrows(0,0,A[1,1],A[2,1], length = 0.05, col = rgb(0,0,0.8,0.7))
arrows(0,0,A[1,2],A[2,2], length = 0.05, col = rgb(0,0,0.8,0.7))
}
# span transformed basis vectors
arrows(-A[1,1]*maxMat,-A[2,1]*maxMat,
A[1,1]*maxMat,A[2,1]*maxMat,
length = 0.05, col = rgb(0,0,0.8,0.3), code = 0, lty = 2)
arrows(-A[1,2]*maxMat,-A[2,2]*maxMat,
A[1,2]*maxMat,A[2,2]*maxMat,
length = 0.05, col = rgb(0,0,0.8,0.3), code = 0, lty = 2)
# input vector transformed
arrows(0,0,v_trans[1],v_trans[2], length = 0.05, col = rgb(0.5,0,0.8,0.8))
text(v_trans[1],v_trans[2]+offset,paste("[",v_trans[1],v_trans[2],"]"),
col = rgb(0.5,0,0.8,0.8), cex = 0.75)
# legend
legend("bottomright", c("Basis","Vector y (Ax=y)"),
col = c(rgb(0,0,0.8,0.7),rgb(0.8,0,0.8,0.7)),
pch = c(16,16), inset=c(0,1), xpd=TRUE, horiz=T, bty="n",
cex = 0.75)
# restore par settings to default
par(mfrow = c(1,1))
}
plotMatrixTransformation(A,c(1,3),offset = 2)
offset//2
plotMatrixTransformation <- function(A,v,
offset = 1,
plotBasisVecs = T,
splitPlot = T){
# assumptions for function:
if (all(dim(A) != 2)){
message("A is not 2x2. Exiting...")
return(NULL)
}
par(mfrow = c(1,2),pty="s")
maxMat = max(A) + offset
plot(1, type = "n",
xlab = "", ylab = "",
xlim = c(-maxMat, maxMat), ylim = c(-maxMat, maxMat),
main = "Before Transformation", cex.main = 0.75)
grid()
# basis vectors
if (plotBasisVecs){
arrows(0,0,0,1, length = 0.05)
arrows(0,0,1,0, length = 0.05)
}
# span basis vectors
arrows(0,-1*2*maxMat,0,1*2*maxMat,
length = 0.05, col = rgb(0,0,0,0.3), code = 0, lty = 2)
arrows(-1*2*maxMat,0,1*2*maxMat,0,
length = 0.05, col = rgb(0,0,0,0.3), code = 0, lty = 2)
# input vector
arrows(0,0,v[1],v[2], length = 0.05, col = rgb(0.8,0,0,0.8))
text(v[1],v[2]+round(offset/2),paste("[",v_trans[1],v_trans[2],"]"),
col = rgb(0.8,0,0,0.8), cex = 0.75)
# plot origin and tip of vec
points(0,0, pch = 16, cex = 0.7,)
points(0,0, pch = 16, cex = 0.7,)
# legend
legend("bottomright", c("Basis","Vector x (Ax=y)"),
col = c(rgb(0,0,0.8,0.7),rgb(0.8,0,0.8,0.7)),
pch = c(16,16), inset=c(0,1), xpd=TRUE, horiz=T, bty="n",
cex = 0.75)
# second plot with transformation
# find new boundaries
v_trans = A%*%v
if (max(v_trans) > maxMat){
maxMat = max(v_trans) + offset
}
if (splitPlot){
# emtpy plot
plot(1, type = "n",
xlab = "", ylab = "",
xlim = c(-maxMat, maxMat), ylim = c(-maxMat, maxMat),
main = "After Transformation", cex.main = 0.75)
# formula for getting angle between vectors
angle <- function(v1,v2){
acos( sum(v1*v2) / ( sqrt(sum(v1*v1)) * sqrt(sum(v2*v2)) ) )
}
# find angle
angle1 = angle(c(1,0),A[,1])
angle2 = -angle(c(0,1),A[,2])
# apply grid (swipe through grid in intervals (seq) and draw abline with slope = angle)
sapply(seq(-maxMat*10,maxMat*10,by=1), function(inter) abline(a=inter,
b=tan(angle1),
lty=3,
col="lightgray"))
sapply(seq(-maxMat*10,maxMat*10,by=4), function(inter) abline(a=inter,
b=tan(angle2+pi/2),
lty=3,
col="lightgray"))
}
# transformed basis vectors
if (plotBasisVecs){
arrows(0,0,A[1,1],A[2,1], length = 0.05, col = rgb(0,0,0.8,0.7))
arrows(0,0,A[1,2],A[2,2], length = 0.05, col = rgb(0,0,0.8,0.7))
}
# span transformed basis vectors
arrows(-A[1,1]*maxMat,-A[2,1]*maxMat,
A[1,1]*maxMat,A[2,1]*maxMat,
length = 0.05, col = rgb(0,0,0.8,0.3), code = 0, lty = 2)
arrows(-A[1,2]*maxMat,-A[2,2]*maxMat,
A[1,2]*maxMat,A[2,2]*maxMat,
length = 0.05, col = rgb(0,0,0.8,0.3), code = 0, lty = 2)
# input vector transformed
arrows(0,0,v_trans[1],v_trans[2], length = 0.05, col = rgb(0.5,0,0.8,0.8))
text(v_trans[1],v_trans[2]+round(offset/2),paste("[",v_trans[1],v_trans[2],"]"),
col = rgb(0.5,0,0.8,0.8), cex = 0.75)
# legend
legend("bottomright", c("Basis","Vector y (Ax=y)"),
col = c(rgb(0,0,0.8,0.7),rgb(0.8,0,0.8,0.7)),
pch = c(16,16), inset=c(0,1), xpd=TRUE, horiz=T, bty="n",
cex = 0.75)
# restore par settings to default
par(mfrow = c(1,1))
}
plotMatrixTransformation(A,c(1,3),offset = 2)
plotMatrixTransformation <- function(A,v,
offset = 1,
plotBasisVecs = T,
splitPlot = T){
# assumptions for function:
if (all(dim(A) != 2)){
message("A is not 2x2. Exiting...")
return(NULL)
}
par(mfrow = c(1,2),pty="s")
maxMat = max(A) + offset
plot(1, type = "n",
xlab = "", ylab = "",
xlim = c(-maxMat, maxMat), ylim = c(-maxMat, maxMat),
main = "Before Transformation", cex.main = 0.75)
grid()
# basis vectors
if (plotBasisVecs){
arrows(0,0,0,1, length = 0.05)
arrows(0,0,1,0, length = 0.05)
}
# span basis vectors
arrows(0,-1*2*maxMat,0,1*2*maxMat,
length = 0.05, col = rgb(0,0,0,0.3), code = 0, lty = 2)
arrows(-1*2*maxMat,0,1*2*maxMat,0,
length = 0.05, col = rgb(0,0,0,0.3), code = 0, lty = 2)
# input vector
arrows(0,0,v[1],v[2], length = 0.05, col = rgb(0.8,0,0,0.8))
text(v[1],v[2]+round(offset/2),paste("[",v[1],v[2],"]"),
col = rgb(0.8,0,0,0.8), cex = 0.75)
# plot origin and tip of vec
points(0,0, pch = 16, cex = 0.7,)
points(0,0, pch = 16, cex = 0.7,)
# legend
legend("bottomright", c("Basis","Vector x (Ax=y)"),
col = c(rgb(0,0,0.8,0.7),rgb(0.8,0,0.8,0.7)),
pch = c(16,16), inset=c(0,1), xpd=TRUE, horiz=T, bty="n",
cex = 0.75)
# second plot with transformation
# find new boundaries
v_trans = A%*%v
if (max(v_trans) > maxMat){
maxMat = max(v_trans) + offset
}
if (splitPlot){
# emtpy plot
plot(1, type = "n",
xlab = "", ylab = "",
xlim = c(-maxMat, maxMat), ylim = c(-maxMat, maxMat),
main = "After Transformation", cex.main = 0.75)
# formula for getting angle between vectors
angle <- function(v1,v2){
acos( sum(v1*v2) / ( sqrt(sum(v1*v1)) * sqrt(sum(v2*v2)) ) )
}
# find angle
angle1 = angle(c(1,0),A[,1])
angle2 = -angle(c(0,1),A[,2])
# apply grid (swipe through grid in intervals (seq) and draw abline with slope = angle)
sapply(seq(-maxMat*10,maxMat*10,by=1), function(inter) abline(a=inter,
b=tan(angle1),
lty=3,
col="lightgray"))
sapply(seq(-maxMat*10,maxMat*10,by=4), function(inter) abline(a=inter,
b=tan(angle2+pi/2),
lty=3,
col="lightgray"))
}
# transformed basis vectors
if (plotBasisVecs){
arrows(0,0,A[1,1],A[2,1], length = 0.05, col = rgb(0,0,0.8,0.7))
arrows(0,0,A[1,2],A[2,2], length = 0.05, col = rgb(0,0,0.8,0.7))
}
# span transformed basis vectors
arrows(-A[1,1]*maxMat,-A[2,1]*maxMat,
A[1,1]*maxMat,A[2,1]*maxMat,
length = 0.05, col = rgb(0,0,0.8,0.3), code = 0, lty = 2)
arrows(-A[1,2]*maxMat,-A[2,2]*maxMat,
A[1,2]*maxMat,A[2,2]*maxMat,
length = 0.05, col = rgb(0,0,0.8,0.3), code = 0, lty = 2)
# input vector transformed
arrows(0,0,v_trans[1],v_trans[2], length = 0.05, col = rgb(0.5,0,0.8,0.8))
text(v_trans[1],v_trans[2]+round(offset/2),paste("[",v_trans[1],v_trans[2],"]"),
col = rgb(0.5,0,0.8,0.8), cex = 0.75)
# legend
legend("bottomright", c("Basis","Vector y (Ax=y)"),
col = c(rgb(0,0,0.8,0.7),rgb(0.8,0,0.8,0.7)),
pch = c(16,16), inset=c(0,1), xpd=TRUE, horiz=T, bty="n",
cex = 0.75)
# restore par settings to default
par(mfrow = c(1,1))
}
plotMatrixTransformation(A,c(1,3),offset = 2)
# full rank - all positive entries
A <- t(matrix(c(2,0,2,
3,4,5,
17,13,0), nrow = 3))
# test 1 - symmetry
A
# test 1 - symmetry
round(A, 3)
# test 1 - symmetry
round(A, 3) == round(t(A),3)
# symmetric + pos def
A <- t(matrix(c(2,2,1,
2,5,1,
1,1,2), nrow = 3))
# test 1 - symmetry
round(A, 3) == round(t(A),3)
# test 1 - symmetry
round(A, 5) == round(t(A),5)
# test 2 - positive eigenvalues
eigen(A)
# test 1 - symmetry
all(round(A, 5) == round(t(A),5))
eigen(A)$value
prod(c(1,2,3,4,5,6))
factorial(6)
# test 2 - positive eigenvalues
test2 = prod(eigen(A)$value) > 0
test2
# test 3 - positive upper left submatrices
nrow(A)
# test 3 - positive upper left submatrices
dimA = nrow(A)
for (i in dimA){
print(det(A[1:i,1:i]))
}
# test 3 - positive upper left submatrices
dimA = nrow(A)
for (i in 1:dimA){
print(det(A[1:i,1:i]))
}
A
A[1:1,1:1]
A[1:2,1:2]
A[1:3,1:3]
det(A[1:3,1:3])
det(A[1:2,1:2])
det(A[1:1,1:1])
# test 1 - symmetry
test1 = all(round(A, 5) == round(t(A),5))
# test 2 - positive eigenvalues
test2 = prod(eigen(A)$value) > 0
# test 1 - symmetry
test1 = all(round(A, 5) == round(t(A),5))
# test 2 - positive eigenvalues
test2 = prod(eigen(A)$value) > 0
# test 3 - positive upper left submatrices
dimA = nrow(A)
upLeftDets = c()
if (A[1,1] < 0){
test3 = FALSE
} else{
for (i in 2:dimA){
upLeftDet = det(A[1:i,1:i])
if (upLeftDet < 0){
test3 = FALSE
} else {
upLeftDets = c(upLeftDets,det(A[1:i,1:i]))
}
}
}
upLeftDets
# test 1 - symmetry
test1 = all(round(A, 5) == round(t(A),5))
# test 2 - positive eigenvalues
test2 = prod(eigen(A)$value) > 0
# test 3 - positive upper left submatrices
dimA = nrow(A)
upLeftDets = c(A[1,1])
if (A[1,1] < 0){
test3 = FALSE
} else {
for (i in 2:dimA){
upLeftDet = det(A[1:i,1:i])
if (upLeftDet < 0){
test3 = FALSE
} else {
upLeftDets = c(upLeftDets,det(A[1:i,1:i]))
}
}
}
upLeftDets
test3 = all(upLeftDets > 0)
all(test1,test2,test3)
