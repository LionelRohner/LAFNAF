A = gaussian_Elimination(A,idxNonzero,col)
}
next
}
# if a leading one exists, swap and continue
if (all(A[idxPivot,1:col-1] == 0)){
# swap
A <- swap(A,idxPivot,currentRow)
# 2.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = col)){
# find nonzero elements in col. vector
idxNonzero = which(A[-c(1:currentRow),col]!=0) + col
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,col)
}
# prep next it
currentRow = currentRow + 1
}
A
A2
A = A2
idxPivot
A
all(A[idxPivot,1:col-1] == 0)
swap(A,idxPivot,currentRow)
# if
!col_Is_All_Zero(A,currentCol = col)
idxNonzero = which(A[-c(1:currentRow),col]!=0) + col
idxNonzero
gaussian_Elimination(A,idxNonzero,col)
A
A2
A = A2
# 3.) find potential next pivots and swap rows if exist
nextPivot = 2
currentCol = col = 2
currentRow = 1
A
# skip if col is zero
if (all(A[-c(1:currentRow),col] == 0)){
message("yes")
# next
}
idxPivot = which(A[-c(1:currentRow),col] == 1)[1] + currentRow
idxPivot
all(A[idxPivot,1:col-1] == 0)
swap(A,idxPivot,currentRow)
A
idxPivot
all(A[idxPivot,1:col-1] == 0)
swap(A,idxPivot,currentRow)
currentRow
# 3.) find potential next pivots and swap rows if exist
nextPivot = 2
currentCol = col = 2
currentRow = 1
A
A
# skip if col is zero
if (all(A[-c(1:currentRow),col] == 0)){
message("yes")
# next
}
idxPivot = which(A[-c(1:currentRow),col] == 1)[1] + currentRow
idxPivot
A = A2
all(A[idxPivot,1:col-1] == 0)
swap(A,idxPivot,currentRow+1)
swap(A,idxPivot,col)
A = swap(A,idxPivot,col)
# if
!col_Is_All_Zero(A,currentCol = col)
idxNonzero = which(A[-c(1:currentRow),col]!=0) + col
idxNonzero
A[-c(1:currentRow),col]
idxNonzero = which(A[-c(1:currentRow+1),col]!=0) + col
idxNonzero
A[-c(1:currentRow+1),col]
idxNonzero = which(A[-c(1:currentRow-1),col]!=0) + col
idxNonzero
A[-c(1:currentRow-1),col]
1:currentRow-1
A[-c(1:currentRow),col]
A[-c(1:currentRow+1),col]
A
currentRow
1:currentRow+1
A[-c(1:currentRow+1),col]
c(1:currentRow+1)
1:currentRow+1
currentRow
(currentRow+1)
# find nonzero elements in col. vector
idxNonzero = which(A[-c(1:(currentRow+1)),col]!=0) + col
idxNonzero = which(A[-c(1:(currentRow+1)),col]!=0) + col
idxNonzero
gaussian_Elimination(A,idxNonzero,col)
A = A2
A
# make loop easier
for (col in currentCol:nc){
# skip if col is zero
if (all(A[-c(1:currentRow),col] == 0)){
next
}
idxPivot = which(A[-c(1:currentRow),col] == 1)[1] + currentRow
# if no leading ones, create one
if (is.na(idxPivot)){
# if leading one does not exist, create one
A[currentRow+1,] = (1/A[currentRow+1,col]) * A[currentRow+1,]
currentRow = currentRow + 1
# 2.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = col)){
# find nonzero elements in col. vector
idxNonzero = which(A[-c(1:currentRow),col]!=0) + col
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,col)
}
next
}
# if a leading one exists, swap and continue
if (all(A[idxPivot,1:col-1] == 0)){
# swap
A <- swap(A,idxPivot,currentRow)
# 2.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = col)){
# find nonzero elements in col. vector
idxNonzero = which(A[-c(1:(currentRow+1)),col]!=0) + col
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,col)
}
# prep next it
currentRow = currentRow + 1
}
}
A
A = A2
A
# make loop easier
for (col in currentCol:nc){
# skip if col is zero
if (all(A[-c(1:currentRow),col] == 0)){
next
}
idxPivot = which(A[-c(1:currentRow),col] == 1)[1] + currentRow
# if no leading ones, create one
if (is.na(idxPivot)){
# if leading one does not exist, create one
A[currentRow+1,] = (1/A[currentRow+1,col]) * A[currentRow+1,]
# 2.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = col)){
# find nonzero elements in col. vector
idxNonzero = which(A[-c(1:currentRow),col]!=0) + col
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,col)
}
currentRow = currentRow + 1
next
}
# if a leading one exists, swap and continue
if (all(A[idxPivot,1:col-1] == 0)){
# swap
A <- swap(A,idxPivot,currentRow)
# 2.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = col)){
# find nonzero elements in col. vector
idxNonzero = which(A[-c(1:(currentRow+1)),col]!=0) + col
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,col)
}
# prep next it
currentRow = currentRow + 1
}
}
A
A = A2
A
# make loop easier
for (col in currentCol:nc){
# # skip if col is zero
# if (all(A[-c(1:currentRow),col] == 0)){
#   next
# }
#
# idxPivot = which(A[-c(1:currentRow),col] == 1)[1] + currentRow
#
# # if no leading ones, create one
# if (is.na(idxPivot)){
#
#   # if leading one does not exist, create one
#   A[currentRow+1,] = (1/A[currentRow+1,col]) * A[currentRow+1,]
#
#
#   # 2.1.) Check if column are all 0 except for the row with the pivot
#   if (!col_Is_All_Zero(A,currentCol = col)){
#
#     # find nonzero elements in col. vector
#     idxNonzero = which(A[-c(1:currentRow),col]!=0) + col
#
#     # Perform Elementary Row OPs
#     A = gaussian_Elimination(A,idxNonzero,col)
#   }
#   currentRow = currentRow + 1
#   next
# }
#
# if a leading one exists, swap and continue
if (all(A[idxPivot,1:col-1] == 0)){
# swap
A <- swap(A,idxPivot,currentRow)
# 2.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = col)){
# find nonzero elements in col. vector
idxNonzero = which(A[-c(1:(currentRow+1)),col]!=0) + col
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,col)
}
# prep next it
currentRow = currentRow + 1
}
}
A
A = A2
A
# make loop easier
for (col in currentCol:nc){
# # skip if col is zero
# if (all(A[-c(1:currentRow),col] == 0)){
#   next
# }
#
idxPivot = which(A[-c(1:currentRow),col] == 1)[1] + currentRow
#
# # if no leading ones, create one
# if (is.na(idxPivot)){
#
#   # if leading one does not exist, create one
#   A[currentRow+1,] = (1/A[currentRow+1,col]) * A[currentRow+1,]
#
#
#   # 2.1.) Check if column are all 0 except for the row with the pivot
#   if (!col_Is_All_Zero(A,currentCol = col)){
#
#     # find nonzero elements in col. vector
#     idxNonzero = which(A[-c(1:currentRow),col]!=0) + col
#
#     # Perform Elementary Row OPs
#     A = gaussian_Elimination(A,idxNonzero,col)
#   }
#   currentRow = currentRow + 1
#   next
# }
#
# if a leading one exists, swap and continue
if (all(A[idxPivot,1:col-1] == 0)){
# swap
A <- swap(A,idxPivot,currentRow)
# 2.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = col)){
# find nonzero elements in col. vector
idxNonzero = which(A[-c(1:(currentRow+1)),col]!=0) + col
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,col)
}
# prep next it
currentRow = currentRow + 1
}
}
A
A
# make loop even easier
for (col in currentCol:nc){
# skip if col is zero
if (all(A[-c(1:currentRow),col] == 0)){
next
}
# go one row down to follow the diagonal if the column is not full of zeros
currentRow = currentRow + 1
# create new pivot
A[currentRow,] = (1/A[currentRow,col]) * A[currentRow,]
# 2.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = col)){
# find nonzero elements in col. vector
idxNonzero = which(A[-c(1:currentRow),col]!=0) + col
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,col)
}
}
A
# 3.) find potential next pivots and swap rows if exist
nextPivot = 2
currentCol = col = 2
currentRow = 1
A = A2
A
# if 1
all(A[-c(1:currentRow),col] == 0)
currentRow = currentRow + 1
A[currentRow,] = (1/A[currentRow,col]) * A[currentRow,]
A
# if 2
(!col_Is_All_Zero(A,currentCol = col))
idxNonzero = which(A[-c(1:currentRow),col]!=0) + col
idxNonzero
gaussian_Elimination(A,idxNonzero,col)
currentCol = col = 2 + 1
currentRow = 1 + 1
A
A = gaussian_Elimination(A,idxNonzero,col)
A = A2
A
# if 1
all(A[-c(1:currentRow),col] == 0)
currentRow = currentRow + 1
A[currentRow,] = (1/A[currentRow,col]) * A[currentRow,]
A
currentRow = 1
currentCol = col = 2
A = A2
A
# if 1
all(A[-c(1:currentRow),col] == 0)
currentRow = currentRow + 1
A[currentRow,] = (1/A[currentRow,col]) * A[currentRow,]
A
# if 2
(!col_Is_All_Zero(A,currentCol = col))
idxNonzero = which(A[-c(1:currentRow),col]!=0) + col
A = gaussian_Elimination(A,idxNonzero,col)
A
currentCol = col = 2 + 1
currentRow = 1 + 1
A
# if 1
all(A[-c(1:currentRow),col] == 0)
currentRow = currentRow + 1
A[currentRow,] = (1/A[currentRow,col]) * A[currentRow,]
A
# if 2
(!col_Is_All_Zero(A,currentCol = col))
idxNonzero = which(A[-c(1:currentRow),col]!=0) + col
idxNonzero
A = gaussian_Elimination(A,idxNonzero,col)
A
currentCol = col = 2
currentRow = 1
A = A2
# make loop even easier
for (col in currentCol:nc){
# skip if col is zero
if (all(A[-c(1:currentRow),col] == 0)){
next
}
# go one row down to follow the diagonal if the column is not full of zeros
currentRow = currentRow + 1
# create new pivot
A[currentRow,] = (1/A[currentRow,col]) * A[currentRow,]
# 2.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = col)){
# find nonzero elements in col. vector
idxNonzero = which(A[-c(1:currentRow),col]!=0) + col
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,col)
}
}
A
rref <- function(A){
# 1.) Setup variables
nc = ncol(A)
nr = nrow(A)
# first pivot must be on first column
currentCol = 1
idxPivot = 1
# 1.1.) remove parallel vectors
rmIdx = unique(linDep_Cautchy_Schwartz_Matrix(A)$j)
# 1.2.) set small values to zero
ifelse(abs(A) <= 1e-10, 0, A)
# put zero-vector and parallel vectors at the bottom
if (!is.null(rmIdx)){
A[rmIdx,] <- rep(0,nc)
A <- append_to_bottom(A,rmIdx)
}
# 2.) find first pivot (if exists, else normalize first row to first element)
firstPivotIdx = which(A[,1]==1)[1]
# check if a pivot exists?
if (!is.na(firstPivotIdx)){
A <- swap(A,firstPivotIdx,1)
} else {
# Create a pivot (normalize first row)
A[1,] = (1/A[1,1]) * A[1,]
}
# 2.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = currentCol)){
# find nonzero elements in col. vector
idxNonzero = which(A[-idxPivot,currentCol]!=0) + currentCol
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,currentCol)
}
# 2.2.) Reorganize matrix such that zero vectors are at the bottom, rm parallel vectors
A = swap_Zero_Vectors(A)
A = remove_Parallel_Vectors(A)
# 3.) find potential next pivots and swap rows if exist
nextPivot = 2
currentCol = 2
currentRow = 1
# make loop even easier
for (col in currentCol:nc){
# skip if col is zero
if (all(A[-c(1:currentRow),col] == 0)){
next
}
# go one row down to follow the diagonal if the column is not full of zeros
currentRow = currentRow + 1
# create new pivot
A[currentRow,] = (1/A[currentRow,col]) * A[currentRow,]
# 2.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = col)){
# find nonzero elements in col. vector
idxNonzero = which(A[-c(1:currentRow),col]!=0) + col
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,col)
}
}
# detect pivots
A_reduced = A[-find_Zero_Vectors(A),]
nrTest = nrow(A_reduced)
# if (all(diag(A_reduced) == 1)){
#   # if matrix has max rank (e.g. mxn where m <= n, then rank = m)
#   A = rbind(diag(nrTest),matrix(0,nrow = nr-nrTest, ncol = nc))
#   return(A)
# }
#
return(A)
}
rref(A)
rref(A)
rref <- function(A){
# 1.) Setup variables
nc = ncol(A)
nr = nrow(A)
# first pivot must be on first column
currentCol = 1
idxPivot = 1
# 1.1.) remove parallel vectors
rmIdx = unique(linDep_Cautchy_Schwartz_Matrix(A)$j)
# 1.2.) set small values to zero
ifelse(abs(A) <= 1e-10, 0, A)
# put zero-vector and parallel vectors at the bottom
if (!is.null(rmIdx)){
A[rmIdx,] <- rep(0,nc)
A <- append_to_bottom(A,rmIdx)
}
# 2.) find first pivot (if exists, else normalize first row to first element)
firstPivotIdx = which(A[,1]==1)[1]
# check if a pivot exists?
if (!is.na(firstPivotIdx)){
A <- swap(A,firstPivotIdx,1)
} else {
# Create a pivot (normalize first row)
A[1,] = (1/A[1,1]) * A[1,]
}
# 2.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = currentCol)){
# find nonzero elements in col. vector
idxNonzero = which(A[-idxPivot,currentCol]!=0) + currentCol
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,currentCol)
}
# 2.2.) Reorganize matrix such that zero vectors are at the bottom, rm parallel vectors
A = swap_Zero_Vectors(A)
A = remove_Parallel_Vectors(A)
# 3.) find potential next pivots and swap rows if exist
nextPivot = 2
currentCol = 2
currentRow = 1
# make loop even easier
for (col in currentCol:nc){
# skip if col is zero
if (all(A[-c(1:currentRow),col] == 0)){
next
}
# go one row down to follow the diagonal if the column is not full of zeros
currentRow = currentRow + 1
# create new pivot
A[currentRow,] = (1/A[currentRow,col]) * A[currentRow,]
# 2.1.) Check if column are all 0 except for the row with the pivot
if (!col_Is_All_Zero(A,currentCol = col)){
# find nonzero elements in col. vector
idxNonzero = which(A[-c(1:currentRow),col]!=0) + col
# Perform Elementary Row OPs
A = gaussian_Elimination(A,idxNonzero,col)
}
}
# clean output
A_reduced = A[-find_Zero_Vectors(A),]
nrTest = nrow(A_reduced)
# if the number of pivots on the diagonal submatrix of sice col x col = max rank
# then the result must be the identity matrix. This is not a very nice work around
# since actually the algo should perform gaussian elemintation of free variables.
if (all(diag(A_reduced) == 1)){
# if matrix has max rank (e.g. mxn where m <= n, then rank = m)
A = rbind(diag(nrTest),matrix(0,nrow = nr-nrTest, ncol = nc))
return(A)
}
return(A)
}
rref(A)
#
A <- t(matrix(c(6,3,2,
12,6,-2,
24,12,-1), nrow = 3))
rref(A)
