m = ncol(A)
adjA = matrix(NA,nrow = n, ncol = m)
for (i in 1:n){
for (j in 1:m){
adjA[i,j] = (-1)^(i+j)*det(A[-i,-j])
}
}
adjA
library(plm)
library(RConics)
adjoint(A)
A <- t(matrix(c(1,2,3,4,
1,2,3,4,
1,2,3,4,
1,2,3,4,
1,2,3,4,
-1,0,1,-3,
7,1,-2,-3), nrow = 4))
adjugate <- function(A){
n = nrow(A)
m = ncol(A)
# create emtpy cofactor matrix
C = matrix(NA,nrow = n, ncol = m)
# populate the cofactor matrix
for (i in 1:n){
for (j in 1:m){
adjA[i,j] = (-1)^(i+j)*det(A[-i,-j])
}
}
return()
}
adjugate <- function(A){
n = nrow(A)
m = ncol(A)
# create emtpy cofactor matrix
C = matrix(NA,nrow = n, ncol = m)
# populate the cofactor matrix
for (i in 1:n){
for (j in 1:m){
C[i,j] = (-1)^(i+j)*det(A[-i,-j])
}
}
return(t(C))
}
adjoint(A)
adjugate <- function(A){
n = nrow(A)
m = ncol(A)
if (n != m){
message("Matrix must be square!")
return(NULL)
}
# create emtpy cofactor matrix
C = matrix(NA,nrow = n, ncol = m)
# populate the cofactor matrix
for (i in 1:n){
for (j in 1:m){
C[i,j] = (-1)^(i+j)*det(A[-i,-j])
}
}
return(t(C))
}
adjoint(A)
adjoint(A)
A <- t(matrix(c(1,2,3, 4,-2,
-1,0,1,4,-7,
7,1,-2,4,1,
1,0,10,2,0,
213,1,8,6,4), nrow = 5))
adjugate <- function(A){
n = nrow(A)
m = ncol(A)
if (n != m){
message("Matrix must be square!")
return(NULL)
}
# create emtpy cofactor matrix
C = matrix(NA,nrow = n, ncol = m)
# populate the cofactor matrix
for (i in 1:n){
for (j in 1:m){
C[i,j] = (-1)^(i+j)*det(A[-i,-j])
}
}
return(t(C))
}
adjoint(A)
adjoint(A)
adjugate(A) == adjoint(A)
generalized_Inverse <- function(A){
### step 1 : Find a LIN submatrix of order rxr
message("Step 1 : Find a LIN submatrix W of order rxr in A!")
# All idxs in the second col should be lin. dep. with some vecs in the first col
# Hence, removing those entries should guarantee NON-singularity of A
rmIdx <- unique(linDep_Cautchy_Schwartz(A)$j)
# Check whether A is full rank anyways
if (is.null(rmIdx)){
W = A
} else {
# make matrix square
diff_row_col = abs((nrow(A)-length(rmIdx))-ncol(A))
W <- A[-rmIdx, -diff_row_col]
}
# check assumptions for non-singularity
if (det(W) == 0){
message("Hope that never happens ;)")
return(NULL)
}
### step 2 : (W^-1)^T
message("Step 2 : (W^-1)^T!")
# create adjugate matrix - adjugate() doesnt work for 2x2
if (dim(W)[1] == 2){
adj_W = -1*W
diag(adj_W) = rev(diag(W))
} else {
adj_W = adjugate(W)
}
transp_inv_W <- t(adj_W/det(W))
### step 3 : replace elements of A with (W^-1)^T
message("Step 3 : Project rows/cols of (W^-1)^T into a a zero matrix A0 of order dim(A)!")
# Again, if A is non-singular from scratch skip Step 3
if (is.null(rmIdx)){
A0 = transp_inv_W
} else{
A0 <- 0*A
A0[-rmIdx, -diff_row_col] = transp_inv_W
}
### step 4 : t(A)
message("Step 3 : G = A0^T!")
G <- t(A0)
return(G)
}
check_Penrose_Cond <- function(A,
G,
all_Penrose_check = F,
digits = 2){
message("Disclaimer: All matrices are transformed to pure integer matrices first, so consider that...\n")
if (all_Penrose_check == F){
Penrose_1 = all(round(A%*%G%*%A,2) == A)
message("AGA=A is ", Penrose_1)
return(Penrose_1)
} else{
Penrose_1 = all(round(A%*%G%*%A) == A)
message("AGA = A is ", Penrose_1)
Penrose_2 = all(round(G%*%A%*%G,digits = digits) == round(G,digits = digits))
message("GAG = G is ", Penrose_2)
Penrose_3 = all(round(A%*%G) == t(round(A%*%G)))
message("AG = (AG)' is ", Penrose_3)
Penrose_4 = all(round(G%*%A) == t(round(G%*%A)))
message("GA = (GA)' is ", Penrose_4)
return(all(Penrose_1,Penrose_2,Penrose_3,Penrose_4))
}
}
G <- generalized_Inverse(A)
check_Penrose_Cond(A,G, all_Penrose_check = T)
round(G%*%A%*%G,2) == round(G,2)
A <- t(matrix(c(2,2,2,
-2,2,-2,
0,4,0), nrow = 3))
rank_Matrix <- function(A, tol = 1e-12){
return(sum(eigen(A)$values > tol))
#
# # if A is mxn with m != n, then the larger (be it rows or cols) will be lin dep!
# if (ncol(A) > nrow(A)){
#   A = t(A)
# }
#
# # lin.dep indices
# CS_indices <- unique(linDep_Cautchy_Schwartz(A)$j)
# print(CS_indices)
# # if CS_indices is empty, A is full-rank, hence rank = nrow(A) = ncol(A)
# if (is.null(CS_indices)){
#   message("Matrix is full-rank!")
#   return(nrow(A))
# } else {
#   # not full rank situation, due to transposition, nrow(A) > ncol(A)
#   rank = nrow(A)-length(CS_indices)
#   message("Matrix has order ", nrow(A),"x",ncol(A), " and rank ", rank)
#   return(rank)
# }
}
rank_Matrix(A)
A <- t(matrix(c(2,2,2,
-2,2,-2,
0,4,0), nrow = 3))
rank_Matrix <- function(A, tol = 1e-12){
# return(sum(eigen(A)$values > tol))
# if A is mxn with m != n, then the larger (be it rows or cols) will be lin dep!
if (ncol(A) > nrow(A)){
A = t(A)
}
# lin.dep indices
CS_indices <- unique(linDep_Cautchy_Schwartz(A)$j)
print(CS_indices)
# if CS_indices is empty, A is full-rank, hence rank = nrow(A) = ncol(A)
if (is.null(CS_indices)){
message("Matrix is full-rank!")
return(nrow(A))
} else {
# not full rank situation, due to transposition, nrow(A) > ncol(A)
rank = nrow(A)-length(CS_indices)
message("Matrix has order ", nrow(A),"x",ncol(A), " and rank ", rank)
return(rank)
}
}
rank_Matrix(A)
A[1,]+A[2,]
A[1,]+A[2,]==A[3,]
A <- t(matrix(c(2,2,2,
-2,2,-2,
0,4,0), nrow = 3))
P = A%*%t(A)
P
P = A%*%t(A)
P
A <- t(matrix(c(1,-3,5,
0,1,7,
2,-4,28,
3,-13,0,
4,-14,-3,
5,-9,30,
6,2,173), nrow = 3))
P = A%*%t(A)
P
A <- t(matrix(c(2,2,2,
-2,2,-2,
0,4,0), nrow = 3))
P = A%*%t(A)
P[row,]%*%P[row,]
P = A%*%t(A)
row = 1
P[row,]
P[row,]%*%P[row,]
t(P[row,])%*%P[row,]
P = A%*%t(A)
row = 1
for (row in 1:nrow(P)){
P[row,] = sqrt(P[row,]%*%P[row,])*P[row,]
}
P[row,] = sqrt(P[row,]%*%P[row,])*P[row,]
sqrt(P[row,]%*%P[row,])
P[row,]%*%P[row,]
P = A%*%t(A)
row = 1
P[row,]%*%P[row,]
sqrt(P[row,]%*%P[row,])
1/sqrt(P[row,]%*%P[row,])*P[row,]
P[row,] = as.vector(1/sqrt(P[row,]%*%P[row,])*P[row,])
P[row,] = 1/sqrt(P[row,]%*%P[row,])*c(P[row,])
P[row,] = 1/sqrt(c(P[row,]%*%P[row,]))*c(P[row,])
1/sqrt(c(P[row,]%*%P[row,]))*c(P[row,])
P = A%*%t(A)
for (row in 1:nrow(P)){
P[row,] = 1/sqrt(c(P[row,]%*%P[row,]))*c(P[row,])
}
P
P%*%t(P)
t(P)%*%P
sqrt(sum(P[1,]))
sum(P[1,])
sqrt(sum(P[1,]))
P = A%*%t(A)
sqrt(sum(P[1,]))
P[1,]
sum(P[1,])
c(P[row,]%*%P[row,])
P[row,] = 1/sqrt(P[row,]%*%P[row,])*c(P[row,])
sqrt(P[1,])
P = A%*%t(A)
sqrt(P[1,])
P[1,]
sqrt(sum(P[1,]^2))
P = A%*%t(A)
for (row in 1:nrow(P)){
# Normalize Rows
P[row,] = 1/sqrt(c(P[row,]%*%P[row,]))*c(P[row,])
}
sqrt(sum(P[1,]^2))
P
P%*%t(P)
preP = eigen(preP)
preP = A%*%t(A)
preP = eigen(preP)
preP
preP = eigen(preP)$vectors
preP = A%*%t(A)
P = eigen(preP)$vectors
for (row in 1:nrow(P)){
# Normalize Rows
P[row,] = 1/sqrt(c(P[row,]%*%P[row,]))*c(P[row,])
}
P
P%*%t(P)
round(P%*%t(P))
orthogonalize <- function(A){
preQ = A%*%t(A)
Q = eigen(preQ)$vectors
for (row in 1:nrow(Q)){
# Normalize Rows
Q[row,] = 1/sqrt(c(Q[row,]%*%Q[row,]))*c(Q[row,])
}
return(Q)
}
orthogonalize(A)
Q <- orthogonalize(A)
Q <- orthogonalize(A)
Q%*%t(Q)
orthogonalize <- function(A){
preQ = A%*%t(A)
Q = eigen(preQ)$vectors
for (row in 1:nrow(Q)){
# Normalize Rows
Q[row,] = 1/sqrt(c(Q[row,]%*%Q[row,]))*c(Q[row,])
}
Q <- ifelse(Q < 1e-14, 0, Q)
return(Q)
}
Q <- orthogonalize(A)
Q
Q%*%t(Q)
orthogonalize <- function(A){
preQ = A%*%t(A)
Q = eigen(preQ)$vectors
for (row in 1:nrow(Q)){
# Normalize Rows
Q[row,] = 1/sqrt(c(Q[row,]%*%Q[row,]))*c(Q[row,])
}
return(Q)
}
Q <- orthogonalize(A)
eigenVal <- eigen(Q)$values
eigenVal
eigenVal <- eigen(P)$values
eigenVal
rank_Matrix <- function(A, tol = 1e-12){
return(sum(eigen(A)$values > tol))
# # if A is mxn with m != n, then the larger (be it rows or cols) will be lin dep!
# if (ncol(A) > nrow(A)){
#   A = t(A)
# }
#
# # lin.dep indices
# CS_indices <- unique(linDep_Cautchy_Schwartz(A)$j)
# print(CS_indices)
# # if CS_indices is empty, A is full-rank, hence rank = nrow(A) = ncol(A)
# if (is.null(CS_indices)){
#   message("Matrix is full-rank!")
#   return(nrow(A))
# } else {
#   # not full rank situation, due to transposition, nrow(A) > ncol(A)
#   rank = nrow(A)-length(CS_indices)
#   message("Matrix has order ", nrow(A),"x",ncol(A), " and rank ", rank)
#   return(rank)
# }
}
rank_Matrix(A)
rank_Matrix <- function(A, tol = 1e-12){
return(sum(eigen(A)$values > tol))
return(eigen(A))
# # if A is mxn with m != n, then the larger (be it rows or cols) will be lin dep!
# if (ncol(A) > nrow(A)){
#   A = t(A)
# }
#
# # lin.dep indices
# CS_indices <- unique(linDep_Cautchy_Schwartz(A)$j)
# print(CS_indices)
# # if CS_indices is empty, A is full-rank, hence rank = nrow(A) = ncol(A)
# if (is.null(CS_indices)){
#   message("Matrix is full-rank!")
#   return(nrow(A))
# } else {
#   # not full rank situation, due to transposition, nrow(A) > ncol(A)
#   rank = nrow(A)-length(CS_indices)
#   message("Matrix has order ", nrow(A),"x",ncol(A), " and rank ", rank)
#   return(rank)
# }
}
rank_Matrix(A)
rank_Matrix <- function(A, tol = 1e-12){
# return(sum(eigen(A)$values > tol))
return(eigen(A))
# # if A is mxn with m != n, then the larger (be it rows or cols) will be lin dep!
# if (ncol(A) > nrow(A)){
#   A = t(A)
# }
#
# # lin.dep indices
# CS_indices <- unique(linDep_Cautchy_Schwartz(A)$j)
# print(CS_indices)
# # if CS_indices is empty, A is full-rank, hence rank = nrow(A) = ncol(A)
# if (is.null(CS_indices)){
#   message("Matrix is full-rank!")
#   return(nrow(A))
# } else {
#   # not full rank situation, due to transposition, nrow(A) > ncol(A)
#   rank = nrow(A)-length(CS_indices)
#   message("Matrix has order ", nrow(A),"x",ncol(A), " and rank ", rank)
#   return(rank)
# }
}
rank_Matrix(A)
A <- t(matrix(c(2,2,2,
-2,2,-2,
0,4,0), nrow = 3))
rank_Matrix <- function(A, tol = 1e-12){
# return(sum(eigen(A)$values > tol))
return(eigen(A)$values)
# # if A is mxn with m != n, then the larger (be it rows or cols) will be lin dep!
# if (ncol(A) > nrow(A)){
#   A = t(A)
# }
#
# # lin.dep indices
# CS_indices <- unique(linDep_Cautchy_Schwartz(A)$j)
# print(CS_indices)
# # if CS_indices is empty, A is full-rank, hence rank = nrow(A) = ncol(A)
# if (is.null(CS_indices)){
#   message("Matrix is full-rank!")
#   return(nrow(A))
# } else {
#   # not full rank situation, due to transposition, nrow(A) > ncol(A)
#   rank = nrow(A)-length(CS_indices)
#   message("Matrix has order ", nrow(A),"x",ncol(A), " and rank ", rank)
#   return(rank)
# }
}
rank_Matrix(A)
rank_Matrix <- function(A, tol = 1e-12){
# return(sum(eigen(A)$values > tol))
return(eigen(A)$values)
# # if A is mxn with m != n, then the larger (be it rows or cols) will be lin dep!
# if (ncol(A) > nrow(A)){
#   A = t(A)
# }
#
# # lin.dep indices
# CS_indices <- unique(linDep_Cautchy_Schwartz(A)$j)
# print(CS_indices)
# # if CS_indices is empty, A is full-rank, hence rank = nrow(A) = ncol(A)
# if (is.null(CS_indices)){
#   message("Matrix is full-rank!")
#   return(nrow(A))
# } else {
#   # not full rank situation, due to transposition, nrow(A) > ncol(A)
#   rank = nrow(A)-length(CS_indices)
#   message("Matrix has order ", nrow(A),"x",ncol(A), " and rank ", rank)
#   return(rank)
# }
}
rank_Matrix(A)
e <- rank_Matrix(A)
e
Im(e)
Real(e)
R(e)
Im(e)-e
e-Im(e)
Re(e)
rank_Matrix <- function(A, tol = 1e-12){
return(sum(Re(eigen(A)$values) > tol))
# # if A is mxn with m != n, then the larger (be it rows or cols) will be lin dep!
# if (ncol(A) > nrow(A)){
#   A = t(A)
# }
#
# # lin.dep indices
# CS_indices <- unique(linDep_Cautchy_Schwartz(A)$j)
# print(CS_indices)
# # if CS_indices is empty, A is full-rank, hence rank = nrow(A) = ncol(A)
# if (is.null(CS_indices)){
#   message("Matrix is full-rank!")
#   return(nrow(A))
# } else {
#   # not full rank situation, due to transposition, nrow(A) > ncol(A)
#   rank = nrow(A)-length(CS_indices)
#   message("Matrix has order ", nrow(A),"x",ncol(A), " and rank ", rank)
#   return(rank)
# }
}
rank_Matrix(A)
D <- diag(eigneVal)
?diag
D <- matrix(nrow = sum(eigenVal), ncol = sum(eigenVal))
eigenVal <- eigen(P)$values
D <- matrix(nrow = sum(eigenVal), ncol = sum(eigenVal))
D <- matrix(nrow = length(eigenVal), ncol = length(eigenVal))
D
D <- matrix(0,nrow = length(eigenVal), ncol = length(eigenVal))
D
diag(D) <- eigenVal
D
eigenVal
P%*%D%*%t(Q)
# create P
P <- orthogonalize(A)
# create Q
Q <- orthogonalize(t(A))
eigenVal <- eigen(P)$values
D <- matrix(0,nrow = length(eigenVal), ncol = length(eigenVal))
diag(D) <- eigenVal
P%*%D%*%t(Q)
diag(D) <- sqrt(eigenVal)
P%*%D%*%t(Q)
# create P
P <- orthogonalize(A)
# create Q
Q <- orthogonalize(t(A))
eigenVal <- eigen(P)$values
D <- matrix(0,nrow = length(eigenVal), ncol = length(eigenVal))
diag(D) <- sqrt(eigenVal)
P%*%D%*%t(Q)
